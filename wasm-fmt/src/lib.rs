#![no_std]
extern crate alloc;

use alloc::format;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;
use core::fmt::Write;

/// The full (dummy) Operator enum with one variant per opcode.
/// In a real parser these variants would carry proper arguments.
#[derive(Clone)]
pub enum Operator {
    // --- Control instructions ---
    Unreachable,
    Nop,
    Block(u8),
    Loop(u8),
    If(u8),
    Else,
    End,
    Br(u32),
    BrIf(u32),
    BrTable { targets: Vec<u32>, default: u32 },
    Return,
    Call(u32),
    CallIndirect(u32, u32),
    ReturnCall(u32),
    ReturnCallIndirect(u32, u32),
    CallRef(u32),
    ReturnCallRef(u32),
    Delegate(u32),
    Catch(u32),
    Throw(u32),
    Rethrow(u32),
    ThrowRef,
    Drop,
    Select,
    TypedSelect(u32),
    Try(u8),
    CatchAll,

    // --- Variable instructions ---
    LocalGet(u32),
    LocalSet(u32),
    LocalTee(u32),
    GlobalGet(u32),
    GlobalSet(u32),
    TableGet(u32),
    TableSet(u32),

    // --- Memory instructions ---
    I32Load(u32, u32),
    I64Load(u32, u32),
    F32Load(u32, u32),
    F64Load(u32, u32),
    I32Load8_s(u32, u32),
    I32Load8_u(u32, u32),
    I32Load16_s(u32, u32),
    I32Load16_u(u32, u32),
    I64Load8_s(u32, u32),
    I64Load8_u(u32, u32),
    I64Load16_s(u32, u32),
    I64Load16_u(u32, u32),
    I64Load32_s(u32, u32),
    I64Load32_u(u32, u32),
    I32Store(u32, u32),
    I64Store(u32, u32),
    F32Store(u32, u32),
    F64Store(u32, u32),
    I32Store8(u32, u32),
    I32Store16(u32, u32),
    I64Store8(u32, u32),
    I64Store16(u32, u32),
    I64Store32(u32, u32),
    MemorySize(u32),
    MemoryGrow(u32),

    // --- Constants ---
    I32Const(i32),
    I64Const(i64),
    F32Const(u32),
    F64Const(u64),

    // --- Comparison and test operators ---
    I32Eqz,
    I32Eq,
    I32Ne,
    I32Lt_s,
    I32Lt_u,
    I32Gt_s,
    I32Gt_u,
    I32Le_s,
    I32Le_u,
    I32Ge_s,
    I32Ge_u,
    I64Eqz,
    I64Eq,
    I64Ne,
    I64Lt_s,
    I64Lt_u,
    I64Gt_s,
    I64Gt_u,
    I64Le_s,
    I64Le_u,
    I64Ge_s,
    I64Ge_u,
    F32Eq,
    F32Ne,
    F32Lt,
    F32Gt,
    F32Le,
    F32Ge,
    F64Eq,
    F64Ne,
    F64Lt,
    F64Gt,
    F64Le,
    F64Ge,

    // --- Unary numeric operators ---
    I32Clz,
    I32Ctz,
    I32Popcnt,
    I64Clz,
    I64Ctz,
    I64Popcnt,

    // --- Binary numeric operators ---
    I32Add,
    I32Sub,
    I32Mul,
    I32Div_s,
    I32Div_u,
    I32Rem_s,
    I32Rem_u,
    I32And,
    I32Or,
    I32Xor,
    I32Shl,
    I32Shr_s,
    I32Shr_u,
    I32Rotl,
    I32Rotr,
    I64Add,
    I64Sub,
    I64Mul,
    I64Div_s,
    I64Div_u,
    I64Rem_s,
    I64Rem_u,
    I64And,
    I64Or,
    I64Xor,
    I64Shl,
    I64Shr_s,
    I64Shr_u,
    I64Rotl,
    I64Rotr,
    F32Abs,
    F32Neg,
    F32Ceil,
    F32Floor,
    F32Trunc,
    F32Nearest,
    F32Sqrt,
    F32Add,
    F32Sub,
    F32Mul,
    F32Div,
    F32Min,
    F32Max,
    F32Copysign,
    F64Abs,
    F64Neg,
    F64Ceil,
    F64Floor,
    F64Trunc,
    F64Nearest,
    F64Sqrt,
    F64Add,
    F64Sub,
    F64Mul,
    F64Div,
    F64Min,
    F64Max,
    F64Copysign,

    // --- Conversions ---
    I32WrapI64,
    I32TruncF32_s,
    I32TruncF32_u,
    I32TruncF64_s,
    I32TruncF64_u,
    I64ExtendI32_s,
    I64ExtendI32_u,
    I64TruncF32_s,
    I64TruncF32_u,
    I64TruncF64_s,
    I64TruncF64_u,
    F32ConvertI32_s,
    F32ConvertI32_u,
    F32ConvertI64_s,
    F32ConvertI64_u,
    F32DemoteF64,
    F64ConvertI32_s,
    F64ConvertI32_u,
    F64ConvertI64_s,
    F64ConvertI64_u,
    F64PromoteF32,
    I32ReinterpretF32,
    I64ReinterpretF64,
    F32ReinterpretI32,
    F64ReinterpretI64,

    // --- Extensions ---
    I32Extend8_s,
    I32Extend16_s,
    I64Extend8_s,
    I64Extend16_s,
    I64Extend32_s,

    // --- Reference types ---
    RefNull(u8),
    RefIsNull,
    RefFunc(u32),
    RefEq,
    RefAsNonNull,
    BrOnNull(u32),
    BrOnNonNull(u32),

    // --- Continuation instructions ---
    ContNew(u32),
    ContBind(u32, u32),
    Suspend(u32),
    Resume(u32, u32),
    ResumeThrow(u32, u32, u32),
    Switch(u32, u32),

    // --- 0xfb opcodes ---
    StructNew(u32),
    StructNewDefault(u32),
    StructGet(u32, u32),
    StructGetS(u32, u32),
    StructGetU(u32, u32),
    StructSet(u32, u32),
    ArrayNew(u32),
    ArrayNewDefault(u32),
    ArrayNewFixed(u32, u32),
    ArrayNewData(u32, u32),
    ArrayNewElem(u32, u32),
    ArrayGet(u32),
    ArrayGetS(u32),
    ArrayGetU(u32),
    ArraySet(u32),
    ArrayLen,
    ArrayFill(u32),
    ArrayCopy(u32, u32),
    ArrayInitData(u32, u32),
    ArrayInitElem(u32, u32),
    RefTestNonNull(u8),
    RefTestNullable(u8),
    RefCastNonNull(u8),
    RefCastNullable(u8),
    BrOnCast(u32, u8, u8),
    BrOnCastFail(u32, u8, u8),
    AnyConvertExtern,
    ExternConvertAny,
    RefI31,
    I31GetS,
    I31GetU,

    // --- 0xfc opcodes ---
    I32TruncSatF32_s,
    I32TruncSatF32_u,
    I32TruncSatF64_s,
    I32TruncSatF64_u,
    I64TruncSatF32_s,
    I64TruncSatF32_u,
    I64TruncSatF64_s,
    I64TruncSatF64_u,
    MemoryInit(u32, u32),
    DataDrop(u32),
    MemoryCopy(u32, u32),
    MemoryFill(u32),
    TableInit(u32, u32),
    ElemDrop(u32),
    TableCopy(u32, u32),
    TableGrow(u32),
    TableSize(u32),
    TableFill(u32),
    MemoryDiscard(u32),
    Forall(u8),
    Exists(u8),
    Assume(u8),
    Unique(u8),
    I32Uzumaki(u8),
    I64Uzumaki(u16),
    I64Add128,
    I64Sub128,
    I64MulWideS,
    I64MulWideU,

    // --- 0xfe opcodes ---
    MemoryAtomicNotify(u32, u32),
    MemoryAtomicWait32(u32, u32),
    MemoryAtomicWait64(u32, u32),
    AtomicFence,
    I32AtomicLoad(u32, u32),
    I64AtomicLoad(u32, u32),
    I32AtomicLoad8_u(u32, u32),
    I32AtomicLoad16_u(u32, u32),
    I64AtomicLoad8_u(u32, u32),
    I64AtomicLoad16_u(u32, u32),
    I64AtomicLoad32_u(u32, u32),
    I32AtomicStore(u32, u32),
    I64AtomicStore(u32, u32),
    I32AtomicStore8(u32, u32),
    I32AtomicStore16(u32, u32),
    I64AtomicStore8(u32, u32),
    I64AtomicStore16(u32, u32),
    I64AtomicStore32(u32, u32),
    I32AtomicRmwAdd(u32, u32),
    I64AtomicRmwAdd(u32, u32),
    I32AtomicRmw8Add_u(u32, u32),
    I32AtomicRmw16Add_u(u32, u32),
    I64AtomicRmw8Add_u(u32, u32),
    I64AtomicRmw16Add_u(u32, u32),
    I64AtomicRmw32Add_u(u32, u32),
    I32AtomicRmwSub(u32, u32),
    I64AtomicRmwSub(u32, u32),
    I32AtomicRmw8Sub_u(u32, u32),
    I32AtomicRmw16Sub_u(u32, u32),
    I64AtomicRmw8Sub_u(u32, u32),
    I64AtomicRmw16Sub_u(u32, u32),
    I64AtomicRmw32Sub_u(u32, u32),
    I32AtomicRmwAnd(u32, u32),
    I64AtomicRmwAnd(u32, u32),
    I32AtomicRmw8And_u(u32, u32),
    I32AtomicRmw16And_u(u32, u32),
    I64AtomicRmw8And_u(u32, u32),
    I64AtomicRmw16And_u(u32, u32),
    I64AtomicRmw32And_u(u32, u32),
    I32AtomicRmwOr(u32, u32),
    I64AtomicRmwOr(u32, u32),
    I32AtomicRmw8Or_u(u32, u32),
    I32AtomicRmw16Or_u(u32, u32),
    I64AtomicRmw8Or_u(u32, u32),
    I64AtomicRmw16Or_u(u32, u32),
    I64AtomicRmw32Or_u(u32, u32),
    I32AtomicRmwXor(u32, u32),
    I64AtomicRmwXor(u32, u32),
    I32AtomicRmw8Xor_u(u32, u32),
    I32AtomicRmw16Xor_u(u32, u32),
    I64AtomicRmw8Xor_u(u32, u32),
    I64AtomicRmw16Xor_u(u32, u32),
    I64AtomicRmw32Xor_u(u32, u32),
    I32AtomicRmwXchg(u32, u32),
    I64AtomicRmwXchg(u32, u32),
    I32AtomicRmw8Xchg_u(u32, u32),
    I32AtomicRmw16Xchg_u(u32, u32),
    I64AtomicRmw8Xchg_u(u32, u32),
    I64AtomicRmw16Xchg_u(u32, u32),
    I64AtomicRmw32Xchg_u(u32, u32),
    I32AtomicRmwCmpxchg(u32, u32),
    I64AtomicRmwCmpxchg(u32, u32),
    I32AtomicRmw8Cmpxchg_u(u32, u32),
    I32AtomicRmw16Cmpxchg_u(u32, u32),
    I64AtomicRmw8Cmpxchg_u(u32, u32),
    I64AtomicRmw16Cmpxchg_u(u32, u32),
    I64AtomicRmw32Cmpxchg_u(u32, u32),
    GlobalAtomicGet(u32, u32),
    GlobalAtomicSet(u32, u32),
    GlobalAtomicRmwAdd(u32, u32),
    GlobalAtomicRmwSub(u32, u32),
    GlobalAtomicRmwAnd(u32, u32),
    GlobalAtomicRmwOr(u32, u32),
    GlobalAtomicRmwXor(u32, u32),
    GlobalAtomicRmwXchg(u32, u32),
    GlobalAtomicRmwCmpxchg(u32, u32),
    TableAtomicGet(u32, u32),
    TableAtomicSet(u32, u32),
    TableAtomicRmwXchg(u32, u32),
    TableAtomicRmwCmpxchg(u32, u32),
    StructAtomicGet(u32, u32, u32),
    StructAtomicGetS(u32, u32, u32),
    StructAtomicGetU(u32, u32, u32),
    StructAtomicSet(u32, u32, u32),
    StructAtomicRmwAdd(u32, u32, u32),
    StructAtomicRmwSub(u32, u32, u32),
    StructAtomicRmwAnd(u32, u32, u32),
    StructAtomicRmwOr(u32, u32, u32),
    StructAtomicRmwXor(u32, u32, u32),
    StructAtomicRmwXchg(u32, u32, u32),
    StructAtomicRmwCmpxchg(u32, u32, u32),
    ArrayAtomicGet(u32, u32),
    ArrayAtomicGetS(u32, u32),
    ArrayAtomicGetU(u32, u32),
    ArrayAtomicSet(u32, u32),
    ArrayAtomicRmwAdd(u32, u32),
    ArrayAtomicRmwSub(u32, u32),
    ArrayAtomicRmwAnd(u32, u32),
    ArrayAtomicRmwOr(u32, u32),
    ArrayAtomicRmwXor(u32, u32),
    ArrayAtomicRmwXchg(u32, u32),
    ArrayAtomicRmwCmpxchg(u32, u32),
    RefI31Shared,
}

// Implement Debug for Operator by deferring to our formatter.
impl core::fmt::Debug for Operator {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        // Here we simply write the result of format_operator.
        write!(f, "{}", format_operator(self))
    }
}

/// A dummy BinaryReader that “parses” one opcode per byte.
/// (A real implementation would decode variable–length LEB128 data.)
#[derive(Clone)]
pub struct BinaryReader<'a> {
    data: &'a [u8],
    pos: usize,
}

impl<'a> BinaryReader<'a> {
    /// Create a new reader over the given data.
    pub fn new(data: &'a [u8], _original_offset: usize) -> Self {
        BinaryReader { data, pos: 0 }
    }

    /// Return the current offset.
    pub fn original_position(&self) -> usize {
        self.pos
    }

    /// Return true if no more data remains.
    pub fn eof(&self) -> bool {
        self.pos >= self.data.len()
    }

    /// Dummy implementation: read one byte and map it to a specific operator.
    pub fn read_operator(&mut self) -> Result<Operator, &'static str> {
        if self.eof() {
            return Err("EOF reached");
        }
        let byte = self.data[self.pos];
        self.pos += 1;
        // For demonstration we map selected byte values to specific operators.
        // (Not all opcodes can be determined from a single byte.)
        match byte {
            0x00 => Ok(Operator::Unreachable),
            0x01 => Ok(Operator::Nop),
            0x02 => Ok(Operator::Block(0)),
            0x03 => Ok(Operator::Loop(0)),
            0x04 => Ok(Operator::If(0)),
            0x05 => Ok(Operator::Else),
            0x0b => Ok(Operator::End),
            0x0c => Ok(Operator::Br(0)),
            0x0d => Ok(Operator::BrIf(0)),
            0x0e => Ok(Operator::BrTable {
                targets: vec![0],
                default: 0,
            }),
            0x0f => Ok(Operator::Return),
            0x10 => Ok(Operator::Call(0)),
            0x11 => Ok(Operator::CallIndirect(0, 0)),
            0x12 => Ok(Operator::ReturnCall(0)),
            0x13 => Ok(Operator::ReturnCallIndirect(0, 0)),
            0x14 => Ok(Operator::CallRef(0)),
            0x15 => Ok(Operator::ReturnCallRef(0)),
            0x18 => Ok(Operator::Delegate(0)),
            0x19 => Ok(Operator::Catch(0)),
            0x1a => Ok(Operator::Throw(0)),
            0x1b => Ok(Operator::Rethrow(0)),
            0x1c => Ok(Operator::ThrowRef),
            0x1d => Ok(Operator::Drop),
            0x1e => Ok(Operator::Select),
            0x1f => Ok(Operator::TypedSelect(0)),
            0x20 => Ok(Operator::Try(0)),
            0x21 => Ok(Operator::CatchAll),
            0x22 => Ok(Operator::LocalGet(0)),
            0x23 => Ok(Operator::LocalSet(0)),
            0x24 => Ok(Operator::LocalTee(0)),
            0x25 => Ok(Operator::GlobalGet(0)),
            0x26 => Ok(Operator::GlobalSet(0)),
            0x27 => Ok(Operator::TableGet(0)),
            0x28 => Ok(Operator::TableSet(0)),
            0x29 => Ok(Operator::I32Load(0, 0)),
            0x2a => Ok(Operator::I64Load(0, 0)),
            0x2b => Ok(Operator::F32Load(0, 0)),
            0x2c => Ok(Operator::F64Load(0, 0)),
            0x2d => Ok(Operator::I32Load8_s(0, 0)),
            0x2e => Ok(Operator::I32Load8_u(0, 0)),
            0x2f => Ok(Operator::I32Load16_s(0, 0)),
            0x30 => Ok(Operator::I32Load16_u(0, 0)),
            0x31 => Ok(Operator::I64Load8_s(0, 0)),
            0x32 => Ok(Operator::I64Load8_u(0, 0)),
            0x33 => Ok(Operator::I64Load16_s(0, 0)),
            0x34 => Ok(Operator::I64Load16_u(0, 0)),
            0x35 => Ok(Operator::I64Load32_s(0, 0)),
            0x36 => Ok(Operator::I64Load32_u(0, 0)),
            0x37 => Ok(Operator::I32Store(0, 0)),
            0x38 => Ok(Operator::I64Store(0, 0)),
            0x39 => Ok(Operator::F32Store(0, 0)),
            0x3a => Ok(Operator::F64Store(0, 0)),
            0x3b => Ok(Operator::I32Store8(0, 0)),
            0x3c => Ok(Operator::I32Store16(0, 0)),
            0x3d => Ok(Operator::I64Store8(0, 0)),
            0x3e => Ok(Operator::I64Store16(0, 0)),
            0x3f => Ok(Operator::I64Store32(0, 0)),
            0x40 => Ok(Operator::MemorySize(0)),
            0x41 => Ok(Operator::MemoryGrow(0)),
            0x42 => Ok(Operator::I32Const(0)),
            0x43 => Ok(Operator::I64Const(0)),
            0x44 => Ok(Operator::F32Const(0)),
            0x45 => Ok(Operator::F64Const(0)),
            0x46 => Ok(Operator::I32Eqz),
            0x47 => Ok(Operator::I32Eq),
            0x48 => Ok(Operator::I32Ne),
            0x49 => Ok(Operator::I32Lt_s),
            0x4a => Ok(Operator::I32Lt_u),
            0x4b => Ok(Operator::I32Gt_s),
            0x4c => Ok(Operator::I32Gt_u),
            0x4d => Ok(Operator::I32Le_s),
            0x4e => Ok(Operator::I32Le_u),
            0x4f => Ok(Operator::I32Ge_s),
            // … (For brevity, additional byte-to-operator mappings would be added here.)
            0xfb => Ok(Operator::StructNew(0)),
            0xfc => Ok(Operator::I32TruncSatF32_s),
            0xfe => Ok(Operator::MemoryAtomicNotify(0, 0)),
            _ => Err("unknown opcode"),
        }
    }
}

/// Format a slice of bytes as a lowercase hexadecimal string.
fn format_hex(bytes: &[u8]) -> String {
    let mut s = String::new();
    for &b in bytes {
        let _ = write!(s, "{:02x}", b);
    }
    s
}

/// Convert an Operator into a human‑readable mnemonic.
/// (For each variant, we print its name and any parameters.)
fn format_operator(op: &Operator) -> String {
    match op {
        // --- Control instructions ---
        Operator::Unreachable => "unreachable".into(),
        Operator::Nop => "nop".into(),
        Operator::Block(x) => format!("block {}", x),
        Operator::Loop(x) => format!("loop {}", x),
        Operator::If(x) => format!("if {}", x),
        Operator::Else => "else".into(),
        Operator::End => "end".into(),
        Operator::Br(x) => format!("br {}", x),
        Operator::BrIf(x) => format!("br_if {}", x),
        Operator::BrTable { targets, default } => {
            format!("br_table targets={:?} default={}", targets, default)
        }
        Operator::Return => "return".into(),
        Operator::Call(x) => format!("call {}", x),
        Operator::CallIndirect(x, y) => format!("call_indirect {} {}", x, y),
        Operator::ReturnCall(x) => format!("return_call {}", x),
        Operator::ReturnCallIndirect(x, y) => format!("return_call_indirect {} {}", x, y),
        Operator::CallRef(x) => format!("call_ref {}", x),
        Operator::ReturnCallRef(x) => format!("return_call_ref {}", x),
        Operator::Delegate(x) => format!("delegate {}", x),
        Operator::Catch(x) => format!("catch {}", x),
        Operator::Throw(x) => format!("throw {}", x),
        Operator::Rethrow(x) => format!("rethrow {}", x),
        Operator::ThrowRef => "throw_ref".into(),
        Operator::Drop => "drop".into(),
        Operator::Select => "select".into(),
        Operator::TypedSelect(x) => format!("typed_select {}", x),
        Operator::Try(x) => format!("try {}", x),
        Operator::CatchAll => "catch_all".into(),

        // --- Variable instructions ---
        Operator::LocalGet(x) => format!("local.get {}", x),
        Operator::LocalSet(x) => format!("local.set {}", x),
        Operator::LocalTee(x) => format!("local.tee {}", x),
        Operator::GlobalGet(x) => format!("global.get {}", x),
        Operator::GlobalSet(x) => format!("global.set {}", x),
        Operator::TableGet(x) => format!("table.get {}", x),
        Operator::TableSet(x) => format!("table.set {}", x),

        // --- Memory instructions ---
        Operator::I32Load(a, b) => format!("i32.load align={} offset={}", a, b),
        Operator::I64Load(a, b) => format!("i64.load align={} offset={}", a, b),
        Operator::F32Load(a, b) => format!("f32.load align={} offset={}", a, b),
        Operator::F64Load(a, b) => format!("f64.load align={} offset={}", a, b),
        Operator::I32Load8_s(a, b) => format!("i32.load8_s align={} offset={}", a, b),
        Operator::I32Load8_u(a, b) => format!("i32.load8_u align={} offset={}", a, b),
        Operator::I32Load16_s(a, b) => format!("i32.load16_s align={} offset={}", a, b),
        Operator::I32Load16_u(a, b) => format!("i32.load16_u align={} offset={}", a, b),
        Operator::I64Load8_s(a, b) => format!("i64.load8_s align={} offset={}", a, b),
        Operator::I64Load8_u(a, b) => format!("i64.load8_u align={} offset={}", a, b),
        Operator::I64Load16_s(a, b) => format!("i64.load16_s align={} offset={}", a, b),
        Operator::I64Load16_u(a, b) => format!("i64.load16_u align={} offset={}", a, b),
        Operator::I64Load32_s(a, b) => format!("i64.load32_s align={} offset={}", a, b),
        Operator::I64Load32_u(a, b) => format!("i64.load32_u align={} offset={}", a, b),
        Operator::I32Store(a, b) => format!("i32.store align={} offset={}", a, b),
        Operator::I64Store(a, b) => format!("i64.store align={} offset={}", a, b),
        Operator::F32Store(a, b) => format!("f32.store align={} offset={}", a, b),
        Operator::F64Store(a, b) => format!("f64.store align={} offset={}", a, b),
        Operator::I32Store8(a, b) => format!("i32.store8 align={} offset={}", a, b),
        Operator::I32Store16(a, b) => format!("i32.store16 align={} offset={}", a, b),
        Operator::I64Store8(a, b) => format!("i64.store8 align={} offset={}", a, b),
        Operator::I64Store16(a, b) => format!("i64.store16 align={} offset={}", a, b),
        Operator::I64Store32(a, b) => format!("i64.store32 align={} offset={}", a, b),
        Operator::MemorySize(x) => format!("memory.size {}", x),
        Operator::MemoryGrow(x) => format!("memory.grow {}", x),

        // --- Constants ---
        Operator::I32Const(x) => format!("i32.const {}", x),
        Operator::I64Const(x) => format!("i64.const {}", x),
        Operator::F32Const(x) => format!("f32.const 0x{:08x}", x),
        Operator::F64Const(x) => format!("f64.const 0x{:016x}", x),

        // --- Comparison and test operators ---
        Operator::I32Eqz => "i32.eqz".into(),
        Operator::I32Eq => "i32.eq".into(),
        Operator::I32Ne => "i32.ne".into(),
        Operator::I32Lt_s => "i32.lt_s".into(),
        Operator::I32Lt_u => "i32.lt_u".into(),
        Operator::I32Gt_s => "i32.gt_s".into(),
        Operator::I32Gt_u => "i32.gt_u".into(),
        Operator::I32Le_s => "i32.le_s".into(),
        Operator::I32Le_u => "i32.le_u".into(),
        Operator::I32Ge_s => "i32.ge_s".into(),
        Operator::I32Ge_u => "i32.ge_u".into(),
        Operator::I64Eqz => "i64.eqz".into(),
        Operator::I64Eq => "i64.eq".into(),
        Operator::I64Ne => "i64.ne".into(),
        Operator::I64Lt_s => "i64.lt_s".into(),
        Operator::I64Lt_u => "i64.lt_u".into(),
        Operator::I64Gt_s => "i64.gt_s".into(),
        Operator::I64Gt_u => "i64.gt_u".into(),
        Operator::I64Le_s => "i64.le_s".into(),
        Operator::I64Le_u => "i64.le_u".into(),
        Operator::I64Ge_s => "i64.ge_s".into(),
        Operator::I64Ge_u => "i64.ge_u".into(),
        Operator::F32Eq => "f32.eq".into(),
        Operator::F32Ne => "f32.ne".into(),
        Operator::F32Lt => "f32.lt".into(),
        Operator::F32Gt => "f32.gt".into(),
        Operator::F32Le => "f32.le".into(),
        Operator::F32Ge => "f32.ge".into(),
        Operator::F64Eq => "f64.eq".into(),
        Operator::F64Ne => "f64.ne".into(),
        Operator::F64Lt => "f64.lt".into(),
        Operator::F64Gt => "f64.gt".into(),
        Operator::F64Le => "f64.le".into(),
        Operator::F64Ge => "f64.ge".into(),

        // --- Unary numeric operators ---
        Operator::I32Clz => "i32.clz".into(),
        Operator::I32Ctz => "i32.ctz".into(),
        Operator::I32Popcnt => "i32.popcnt".into(),
        Operator::I64Clz => "i64.clz".into(),
        Operator::I64Ctz => "i64.ctz".into(),
        Operator::I64Popcnt => "i64.popcnt".into(),

        // --- Binary numeric operators ---
        Operator::I32Add => "i32.add".into(),
        Operator::I32Sub => "i32.sub".into(),
        Operator::I32Mul => "i32.mul".into(),
        Operator::I32Div_s => "i32.div_s".into(),
        Operator::I32Div_u => "i32.div_u".into(),
        Operator::I32Rem_s => "i32.rem_s".into(),
        Operator::I32Rem_u => "i32.rem_u".into(),
        Operator::I32And => "i32.and".into(),
        Operator::I32Or => "i32.or".into(),
        Operator::I32Xor => "i32.xor".into(),
        Operator::I32Shl => "i32.shl".into(),
        Operator::I32Shr_s => "i32.shr_s".into(),
        Operator::I32Shr_u => "i32.shr_u".into(),
        Operator::I32Rotl => "i32.rotl".into(),
        Operator::I32Rotr => "i32.rotr".into(),
        Operator::I64Add => "i64.add".into(),
        Operator::I64Sub => "i64.sub".into(),
        Operator::I64Mul => "i64.mul".into(),
        Operator::I64Div_s => "i64.div_s".into(),
        Operator::I64Div_u => "i64.div_u".into(),
        Operator::I64Rem_s => "i64.rem_s".into(),
        Operator::I64Rem_u => "i64.rem_u".into(),
        Operator::I64And => "i64.and".into(),
        Operator::I64Or => "i64.or".into(),
        Operator::I64Xor => "i64.xor".into(),
        Operator::I64Shl => "i64.shl".into(),
        Operator::I64Shr_s => "i64.shr_s".into(),
        Operator::I64Shr_u => "i64.shr_u".into(),
        Operator::I64Rotl => "i64.rotl".into(),
        Operator::I64Rotr => "i64.rotr".into(),
        Operator::F32Abs => "f32.abs".into(),
        Operator::F32Neg => "f32.neg".into(),
        Operator::F32Ceil => "f32.ceil".into(),
        Operator::F32Floor => "f32.floor".into(),
        Operator::F32Trunc => "f32.trunc".into(),
        Operator::F32Nearest => "f32.nearest".into(),
        Operator::F32Sqrt => "f32.sqrt".into(),
        Operator::F32Add => "f32.add".into(),
        Operator::F32Sub => "f32.sub".into(),
        Operator::F32Mul => "f32.mul".into(),
        Operator::F32Div => "f32.div".into(),
        Operator::F32Min => "f32.min".into(),
        Operator::F32Max => "f32.max".into(),
        Operator::F32Copysign => "f32.copysign".into(),
        Operator::F64Abs => "f64.abs".into(),
        Operator::F64Neg => "f64.neg".into(),
        Operator::F64Ceil => "f64.ceil".into(),
        Operator::F64Floor => "f64.floor".into(),
        Operator::F64Trunc => "f64.trunc".into(),
        Operator::F64Nearest => "f64.nearest".into(),
        Operator::F64Sqrt => "f64.sqrt".into(),
        Operator::F64Add => "f64.add".into(),
        Operator::F64Sub => "f64.sub".into(),
        Operator::F64Mul => "f64.mul".into(),
        Operator::F64Div => "f64.div".into(),
        Operator::F64Min => "f64.min".into(),
        Operator::F64Max => "f64.max".into(),
        Operator::F64Copysign => "f64.copysign".into(),

        // --- Conversions ---
        Operator::I32WrapI64 => "i32.wrap_i64".into(),
        Operator::I32TruncF32_s => "i32.trunc_f32_s".into(),
        Operator::I32TruncF32_u => "i32.trunc_f32_u".into(),
        Operator::I32TruncF64_s => "i32.trunc_f64_s".into(),
        Operator::I32TruncF64_u => "i32.trunc_f64_u".into(),
        Operator::I64ExtendI32_s => "i64.extend_i32_s".into(),
        Operator::I64ExtendI32_u => "i64.extend_i32_u".into(),
        Operator::I64TruncF32_s => "i64.trunc_f32_s".into(),
        Operator::I64TruncF32_u => "i64.trunc_f32_u".into(),
        Operator::I64TruncF64_s => "i64.trunc_f64_s".into(),
        Operator::I64TruncF64_u => "i64.trunc_f64_u".into(),
        Operator::F32ConvertI32_s => "f32.convert_i32_s".into(),
        Operator::F32ConvertI32_u => "f32.convert_i32_u".into(),
        Operator::F32ConvertI64_s => "f32.convert_i64_s".into(),
        Operator::F32ConvertI64_u => "f32.convert_i64_u".into(),
        Operator::F32DemoteF64 => "f32.demote_f64".into(),
        Operator::F64ConvertI32_s => "f64.convert_i32_s".into(),
        Operator::F64ConvertI32_u => "f64.convert_i32_u".into(),
        Operator::F64ConvertI64_s => "f64.convert_i64_s".into(),
        Operator::F64ConvertI64_u => "f64.convert_i64_u".into(),
        Operator::F64PromoteF32 => "f64.promote_f32".into(),
        Operator::I32ReinterpretF32 => "i32.reinterpret_f32".into(),
        Operator::I64ReinterpretF64 => "i64.reinterpret_f64".into(),
        Operator::F32ReinterpretI32 => "f32.reinterpret_i32".into(),
        Operator::F64ReinterpretI64 => "f64.reinterpret_i64".into(),

        // --- Extensions ---
        Operator::I32Extend8_s => "i32.extend8_s".into(),
        Operator::I32Extend16_s => "i32.extend16_s".into(),
        Operator::I64Extend8_s => "i64.extend8_s".into(),
        Operator::I64Extend16_s => "i64.extend16_s".into(),
        Operator::I64Extend32_s => "i64.extend32_s".into(),

        // --- Reference types ---
        Operator::RefNull(x) => format!("ref.null {}", x),
        Operator::RefIsNull => "ref.is_null".into(),
        Operator::RefFunc(x) => format!("ref.func {}", x),
        Operator::RefEq => "ref.eq".into(),
        Operator::RefAsNonNull => "ref.as_non_null".into(),
        Operator::BrOnNull(x) => format!("br_on_null {}", x),
        Operator::BrOnNonNull(x) => format!("br_on_non_null {}", x),

        // --- Continuation instructions ---
        Operator::ContNew(x) => format!("cont.new {}", x),
        Operator::ContBind(x, y) => format!("cont.bind {} {}", x, y),
        Operator::Suspend(x) => format!("suspend {}", x),
        Operator::Resume(x, y) => format!("resume {} {}", x, y),
        Operator::ResumeThrow(x, y, z) => format!("resume.throw {} {} {}", x, y, z),
        Operator::Switch(x, y) => format!("switch {} {}", x, y),

        // --- 0xfb opcodes ---
        Operator::StructNew(x) => format!("struct.new {}", x),
        Operator::StructNewDefault(x) => format!("struct.new_default {}", x),
        Operator::StructGet(x, y) => format!("struct.get {} {}", x, y),
        Operator::StructGetS(x, y) => format!("struct.get_s {} {}", x, y),
        Operator::StructGetU(x, y) => format!("struct.get_u {} {}", x, y),
        Operator::StructSet(x, y) => format!("struct.set {} {}", x, y),
        Operator::ArrayNew(x) => format!("array.new {}", x),
        Operator::ArrayNewDefault(x) => format!("array.new_default {}", x),
        Operator::ArrayNewFixed(x, y) => format!("array.new_fixed {} {}", x, y),
        Operator::ArrayNewData(x, y) => format!("array.new_data {} {}", x, y),
        Operator::ArrayNewElem(x, y) => format!("array.new_elem {} {}", x, y),
        Operator::ArrayGet(x) => format!("array.get {}", x),
        Operator::ArrayGetS(x) => format!("array.get_s {}", x),
        Operator::ArrayGetU(x) => format!("array.get_u {}", x),
        Operator::ArraySet(x) => format!("array.set {}", x),
        Operator::ArrayLen => "array.len".into(),
        Operator::ArrayFill(x) => format!("array.fill {}", x),
        Operator::ArrayCopy(x, y) => format!("array.copy {} {}", x, y),
        Operator::ArrayInitData(x, y) => format!("array.init_data {} {}", x, y),
        Operator::ArrayInitElem(x, y) => format!("array.init_elem {} {}", x, y),
        Operator::RefTestNonNull(x) => format!("ref.test_non_null {}", x),
        Operator::RefTestNullable(x) => format!("ref.test_nullable {}", x),
        Operator::RefCastNonNull(x) => format!("ref.cast_non_null {}", x),
        Operator::RefCastNullable(x) => format!("ref.cast_nullable {}", x),
        Operator::BrOnCast(x, y, z) => format!("br_on_cast {} {} {}", x, y, z),
        Operator::BrOnCastFail(x, y, z) => format!("br_on_cast_fail {} {} {}", x, y, z),
        Operator::AnyConvertExtern => "any.convert_extern".into(),
        Operator::ExternConvertAny => "extern.convert_any".into(),
        Operator::RefI31 => "ref.i31".into(),
        Operator::I31GetS => "i31.get_s".into(),
        Operator::I31GetU => "i31.get_u".into(),

        // --- 0xfc opcodes ---
        Operator::I32TruncSatF32_s => "i32.trunc_sat_f32_s".into(),
        Operator::I32TruncSatF32_u => "i32.trunc_sat_f32_u".into(),
        Operator::I32TruncSatF64_s => "i32.trunc_sat_f64_s".into(),
        Operator::I32TruncSatF64_u => "i32.trunc_sat_f64_u".into(),
        Operator::I64TruncSatF32_s => "i64.trunc_sat_f32_s".into(),
        Operator::I64TruncSatF32_u => "i64.trunc_sat_f32_u".into(),
        Operator::I64TruncSatF64_s => "i64.trunc_sat_f64_s".into(),
        Operator::I64TruncSatF64_u => "i64.trunc_sat_f64_u".into(),
        Operator::MemoryInit(x, y) => format!("memory.init {} {}", x, y),
        Operator::DataDrop(x) => format!("data.drop {}", x),
        Operator::MemoryCopy(x, y) => format!("memory.copy {} {}", x, y),
        Operator::MemoryFill(x) => format!("memory.fill {}", x),
        Operator::TableInit(x, y) => format!("table.init {} {}", x, y),
        Operator::ElemDrop(x) => format!("elem.drop {}", x),
        Operator::TableCopy(x, y) => format!("table.copy {} {}", x, y),
        Operator::TableGrow(x) => format!("table.grow {}", x),
        Operator::TableSize(x) => format!("table.size {}", x),
        Operator::TableFill(x) => format!("table.fill {}", x),
        Operator::MemoryDiscard(x) => format!("memory.discard {}", x),
        Operator::Forall(x) => format!("forall {}", x),
        Operator::Exists(x) => format!("exists {}", x),
        Operator::Assume(x) => format!("assume {}", x),
        Operator::Unique(x) => format!("unique {}", x),
        Operator::I32Uzumaki(x) => format!("i32.uzumaki {}", x),
        Operator::I64Uzumaki(x) => format!("i64.uzumaki {}", x),
        Operator::I64Add128 => "i64.add128".into(),
        Operator::I64Sub128 => "i64.sub128".into(),
        Operator::I64MulWideS => "i64.mul_wide_s".into(),
        Operator::I64MulWideU => "i64.mul_wide_u".into(),

        // --- 0xfe opcodes ---
        Operator::MemoryAtomicNotify(x, y) => format!("memory.atomic.notify {} {}", x, y),
        Operator::MemoryAtomicWait32(x, y) => format!("memory.atomic.wait32 {} {}", x, y),
        Operator::MemoryAtomicWait64(x, y) => format!("memory.atomic.wait64 {} {}", x, y),
        Operator::AtomicFence => "atomic.fence".into(),
        Operator::I32AtomicLoad(x, y) => format!("i32.atomic.load {} {}", x, y),
        Operator::I64AtomicLoad(x, y) => format!("i64.atomic.load {} {}", x, y),
        Operator::I32AtomicLoad8_u(x, y) => format!("i32.atomic.load8_u {} {}", x, y),
        Operator::I32AtomicLoad16_u(x, y) => format!("i32.atomic.load16_u {} {}", x, y),
        Operator::I64AtomicLoad8_u(x, y) => format!("i64.atomic.load8_u {} {}", x, y),
        Operator::I64AtomicLoad16_u(x, y) => format!("i64.atomic.load16_u {} {}", x, y),
        Operator::I64AtomicLoad32_u(x, y) => format!("i64.atomic.load32_u {} {}", x, y),
        Operator::I32AtomicStore(x, y) => format!("i32.atomic.store {} {}", x, y),
        Operator::I64AtomicStore(x, y) => format!("i64.atomic.store {} {}", x, y),
        Operator::I32AtomicStore8(x, y) => format!("i32.atomic.store8 {} {}", x, y),
        Operator::I32AtomicStore16(x, y) => format!("i32.atomic.store16 {} {}", x, y),
        Operator::I64AtomicStore8(x, y) => format!("i64.atomic.store8 {} {}", x, y),
        Operator::I64AtomicStore16(x, y) => format!("i64.atomic.store16 {} {}", x, y),
        Operator::I64AtomicStore32(x, y) => format!("i64.atomic.store32 {} {}", x, y),
        Operator::I32AtomicRmwAdd(x, y) => format!("i32.atomic.rmw.add {} {}", x, y),
        Operator::I64AtomicRmwAdd(x, y) => format!("i64.atomic.rmw.add {} {}", x, y),
        Operator::I32AtomicRmw8Add_u(x, y) => format!("i32.atomic.rmw8.add_u {} {}", x, y),
        Operator::I32AtomicRmw16Add_u(x, y) => format!("i32.atomic.rmw16.add_u {} {}", x, y),
        Operator::I64AtomicRmw8Add_u(x, y) => format!("i64.atomic.rmw8.add_u {} {}", x, y),
        Operator::I64AtomicRmw16Add_u(x, y) => format!("i64.atomic.rmw16.add_u {} {}", x, y),
        Operator::I64AtomicRmw32Add_u(x, y) => format!("i64.atomic.rmw32.add_u {} {}", x, y),
        Operator::I32AtomicRmwSub(x, y) => format!("i32.atomic.rmw.sub {} {}", x, y),
        Operator::I64AtomicRmwSub(x, y) => format!("i64.atomic.rmw.sub {} {}", x, y),
        Operator::I32AtomicRmw8Sub_u(x, y) => format!("i32.atomic.rmw8.sub_u {} {}", x, y),
        Operator::I32AtomicRmw16Sub_u(x, y) => format!("i32.atomic.rmw16.sub_u {} {}", x, y),
        Operator::I64AtomicRmw8Sub_u(x, y) => format!("i64.atomic.rmw8.sub_u {} {}", x, y),
        Operator::I64AtomicRmw16Sub_u(x, y) => format!("i64.atomic.rmw16.sub_u {} {}", x, y),
        Operator::I64AtomicRmw32Sub_u(x, y) => format!("i64.atomic.rmw32.sub_u {} {}", x, y),
        Operator::I32AtomicRmwAnd(x, y) => format!("i32.atomic.rmw.and {} {}", x, y),
        Operator::I64AtomicRmwAnd(x, y) => format!("i64.atomic.rmw.and {} {}", x, y),
        Operator::I32AtomicRmw8And_u(x, y) => format!("i32.atomic.rmw8.and_u {} {}", x, y),
        Operator::I32AtomicRmw16And_u(x, y) => format!("i32.atomic.rmw16.and_u {} {}", x, y),
        Operator::I64AtomicRmw8And_u(x, y) => format!("i64.atomic.rmw8.and_u {} {}", x, y),
        Operator::I64AtomicRmw16And_u(x, y) => format!("i64.atomic.rmw16.and_u {} {}", x, y),
        Operator::I64AtomicRmw32And_u(x, y) => format!("i64.atomic.rmw32.and_u {} {}", x, y),
        Operator::I32AtomicRmwOr(x, y) => format!("i32.atomic.rmw.or {} {}", x, y),
        Operator::I64AtomicRmwOr(x, y) => format!("i64.atomic.rmw.or {} {}", x, y),
        Operator::I32AtomicRmw8Or_u(x, y) => format!("i32.atomic.rmw8.or_u {} {}", x, y),
        Operator::I32AtomicRmw16Or_u(x, y) => format!("i32.atomic.rmw16.or_u {} {}", x, y),
        Operator::I64AtomicRmw8Or_u(x, y) => format!("i64.atomic.rmw8.or_u {} {}", x, y),
        Operator::I64AtomicRmw16Or_u(x, y) => format!("i64.atomic.rmw16.or_u {} {}", x, y),
        Operator::I64AtomicRmw32Or_u(x, y) => format!("i64.atomic.rmw32.or_u {} {}", x, y),
        Operator::I32AtomicRmwXor(x, y) => format!("i32.atomic.rmw.xor {} {}", x, y),
        Operator::I64AtomicRmwXor(x, y) => format!("i64.atomic.rmw.xor {} {}", x, y),
        Operator::I32AtomicRmw8Xor_u(x, y) => format!("i32.atomic.rmw8.xor_u {} {}", x, y),
        Operator::I32AtomicRmw16Xor_u(x, y) => format!("i32.atomic.rmw16.xor_u {} {}", x, y),
        Operator::I64AtomicRmw8Xor_u(x, y) => format!("i64.atomic.rmw8.xor_u {} {}", x, y),
        Operator::I64AtomicRmw16Xor_u(x, y) => format!("i64.atomic.rmw16.xor_u {} {}", x, y),
        Operator::I64AtomicRmw32Xor_u(x, y) => format!("i64.atomic.rmw32.xor_u {} {}", x, y),
        Operator::I32AtomicRmwXchg(x, y) => format!("i32.atomic.rmw.xchg {} {}", x, y),
        Operator::I64AtomicRmwXchg(x, y) => format!("i64.atomic.rmw.xchg {} {}", x, y),
        Operator::I32AtomicRmw8Xchg_u(x, y) => format!("i32.atomic.rmw8.xchg_u {} {}", x, y),
        Operator::I32AtomicRmw16Xchg_u(x, y) => format!("i32.atomic.rmw16.xchg_u {} {}", x, y),
        Operator::I64AtomicRmw8Xchg_u(x, y) => format!("i64.atomic.rmw8.xchg_u {} {}", x, y),
        Operator::I64AtomicRmw16Xchg_u(x, y) => format!("i64.atomic.rmw16.xchg_u {} {}", x, y),
        Operator::I64AtomicRmw32Xchg_u(x, y) => format!("i64.atomic.rmw32.xchg_u {} {}", x, y),
        Operator::I32AtomicRmwCmpxchg(x, y) => format!("i32.atomic.rmw.cmpxchg {} {}", x, y),
        Operator::I64AtomicRmwCmpxchg(x, y) => format!("i64.atomic.rmw.cmpxchg {} {}", x, y),
        Operator::I32AtomicRmw8Cmpxchg_u(x, y) => format!("i32.atomic.rmw8.cmpxchg_u {} {}", x, y),
        Operator::I32AtomicRmw16Cmpxchg_u(x, y) => {
            format!("i32.atomic.rmw16.cmpxchg_u {} {}", x, y)
        }
        Operator::I64AtomicRmw8Cmpxchg_u(x, y) => format!("i64.atomic.rmw8.cmpxchg_u {} {}", x, y),
        Operator::I64AtomicRmw16Cmpxchg_u(x, y) => {
            format!("i64.atomic.rmw16.cmpxchg_u {} {}", x, y)
        }
        Operator::I64AtomicRmw32Cmpxchg_u(x, y) => {
            format!("i64.atomic.rmw32.cmpxchg_u {} {}", x, y)
        }
        Operator::GlobalAtomicGet(x, y) => format!("global.atomic.get {} {}", x, y),
        Operator::GlobalAtomicSet(x, y) => format!("global.atomic.set {} {}", x, y),
        Operator::GlobalAtomicRmwAdd(x, y) => format!("global.atomic.rmw.add {} {}", x, y),
        Operator::GlobalAtomicRmwSub(x, y) => format!("global.atomic.rmw.sub {} {}", x, y),
        Operator::GlobalAtomicRmwAnd(x, y) => format!("global.atomic.rmw.and {} {}", x, y),
        Operator::GlobalAtomicRmwOr(x, y) => format!("global.atomic.rmw.or {} {}", x, y),
        Operator::GlobalAtomicRmwXor(x, y) => format!("global.atomic.rmw.xor {} {}", x, y),
        Operator::GlobalAtomicRmwXchg(x, y) => format!("global.atomic.rmw.xchg {} {}", x, y),
        Operator::GlobalAtomicRmwCmpxchg(x, y) => format!("global.atomic.rmw.cmpxchg {} {}", x, y),
        Operator::TableAtomicGet(x, y) => format!("table.atomic.get {} {}", x, y),
        Operator::TableAtomicSet(x, y) => format!("table.atomic.set {} {}", x, y),
        Operator::TableAtomicRmwXchg(x, y) => format!("table.atomic.rmw.xchg {} {}", x, y),
        Operator::TableAtomicRmwCmpxchg(x, y) => format!("table.atomic.rmw.cmpxchg {} {}", x, y),
        Operator::StructAtomicGet(x, y, z) => format!("struct.atomic.get {} {} {}", x, y, z),
        Operator::StructAtomicGetS(x, y, z) => format!("struct.atomic.get_s {} {} {}", x, y, z),
        Operator::StructAtomicGetU(x, y, z) => format!("struct.atomic.get_u {} {} {}", x, y, z),
        Operator::StructAtomicSet(x, y, z) => format!("struct.atomic.set {} {} {}", x, y, z),
        Operator::StructAtomicRmwAdd(x, y, z) => format!("struct.atomic.rmw.add {} {} {}", x, y, z),
        Operator::StructAtomicRmwSub(x, y, z) => format!("struct.atomic.rmw.sub {} {} {}", x, y, z),
        Operator::StructAtomicRmwAnd(x, y, z) => format!("struct.atomic.rmw.and {} {} {}", x, y, z),
        Operator::StructAtomicRmwOr(x, y, z) => format!("struct.atomic.rmw.or {} {} {}", x, y, z),
        Operator::StructAtomicRmwXor(x, y, z) => format!("struct.atomic.rmw.xor {} {} {}", x, y, z),
        Operator::StructAtomicRmwXchg(x, y, z) => {
            format!("struct.atomic.rmw.xchg {} {} {}", x, y, z)
        }
        Operator::StructAtomicRmwCmpxchg(x, y, z) => {
            format!("struct.atomic.rmw.cmpxchg {} {} {}", x, y, z)
        }
        Operator::ArrayAtomicGet(x, y) => format!("array.atomic.get {} {}", x, y),
        Operator::ArrayAtomicGetS(x, y) => format!("array.atomic.get_s {} {}", x, y),
        Operator::ArrayAtomicGetU(x, y) => format!("array.atomic.get_u {} {}", x, y),
        Operator::ArrayAtomicSet(x, y) => format!("array.atomic.set {} {}", x, y),
        Operator::ArrayAtomicRmwAdd(x, y) => format!("array.atomic.rmw.add {} {}", x, y),
        Operator::ArrayAtomicRmwSub(x, y) => format!("array.atomic.rmw.sub {} {}", x, y),
        Operator::ArrayAtomicRmwAnd(x, y) => format!("array.atomic.rmw.and {} {}", x, y),
        Operator::ArrayAtomicRmwOr(x, y) => format!("array.atomic.rmw.or {} {}", x, y),
        Operator::ArrayAtomicRmwXor(x, y) => format!("array.atomic.rmw.xor {} {}", x, y),
        Operator::ArrayAtomicRmwXchg(x, y) => format!("array.atomic.rmw.xchg {} {}", x, y),
        Operator::ArrayAtomicRmwCmpxchg(x, y) => format!("array.atomic.rmw.cmpxchg {} {}", x, y),
        Operator::RefI31Shared => "ref.i31_shared".into(),
    }
}

/// Format a WASM binary (a vector of bytes) into a table of opcodes.
/// Each line shows the raw hex bytes for the opcode (padded to 12 characters),
/// the absolute offset (8-digit hex), and the human‑readable mnemonic.
pub fn format(wasm: &[u8]) -> String {
    let mut output = String::new();
    let mut reader = BinaryReader::new(wasm, 0);
    while !reader.eof() {
        let start = reader.original_position();
        let mut clone = reader.clone();
        match clone.read_operator() {
            Ok(op) => {
                let end = clone.original_position();
                let op_bytes = &wasm[start..end];
                let hex_str = format_hex(op_bytes);
                let mut offset_str = String::new();
                let _ = write!(offset_str, "0x{:08x}", start);
                let mnemonic = format_operator(&op);
                let _ = writeln!(output, "{:12}  {:10}  {}", hex_str, offset_str, mnemonic);
                reader = clone;
            }
            Err(e) => {
                let _ = writeln!(output, "Error at offset 0x{:08x}: {}", start, e);
                break;
            }
        }
    }
    output
}
