{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/toolchain/platform.ts", "../src/toolchain/detection.ts", "../src/config/settings.ts", "../src/utils/exec.ts", "../src/utils/semver.ts", "../src/commands/install.ts", "../src/toolchain/installation.ts", "../src/utils/download.ts", "../src/utils/extract.ts", "../src/toolchain/manifest.ts", "../src/commands/doctor.ts", "../src/toolchain/doctor.ts", "../src/ui/statusBar.ts", "../src/commands/selectVersion.ts", "../src/toolchain/versions.ts", "../src/commands/update.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './toolchain/platform';\nimport { detectInfs } from './toolchain/detection';\nimport { getSettings } from './config/settings';\nimport { exec } from './utils/exec';\nimport { compareSemver } from './utils/semver';\nimport { registerInstallCommand } from './commands/install';\nimport { registerDoctorCommand } from './commands/doctor';\nimport { registerSelectVersionCommand } from './commands/selectVersion';\nimport { registerUpdateCommand, checkForUpdates } from './commands/update';\nimport { createStatusBar, updateStatusBar } from './ui/statusBar';\nimport { runDoctor } from './toolchain/doctor';\n\n/** Minimum infs CLI version the extension can work with. */\nconst MIN_INFS_VERSION = '0.0.1-beta.1';\n\nconst outputChannel = vscode.window.createOutputChannel('Inference');\n\nexport function activate(context: vscode.ExtensionContext) {\n    context.subscriptions.push(outputChannel);\n\n    const statusBarItem = createStatusBar();\n    context.subscriptions.push(statusBarItem);\n\n    context.subscriptions.push(\n        vscode.commands.registerCommand('inference.showOutput', () => {\n            outputChannel.show();\n        }),\n    );\n\n    context.subscriptions.push(registerInstallCommand(outputChannel));\n    context.subscriptions.push(\n        registerDoctorCommand(outputChannel, statusBarItem),\n    );\n\n    context.subscriptions.push(registerUpdateCommand(outputChannel));\n    context.subscriptions.push(registerSelectVersionCommand(outputChannel));\n\n    checkToolchain(statusBarItem).catch((err) =>\n        outputChannel.appendLine(`Toolchain check failed: ${err}`),\n    );\n}\n\nexport function deactivate() {\n    // Nothing to clean up\n}\n\nasync function checkToolchain(\n    statusBarItem: vscode.StatusBarItem,\n): Promise<void> {\n    const platform = detectPlatform();\n    if (!platform) {\n        outputChannel.appendLine(\n            `Unsupported platform: ${process.platform}-${process.arch}`,\n        );\n        updateStatusBar(statusBarItem, null);\n        vscode.window\n            .showWarningMessage(\n                `Inference: unsupported platform (${process.platform}-${process.arch}).`,\n                'Download Page',\n            )\n            .then((action) => {\n                if (action === 'Download Page') {\n                    vscode.env.openExternal(\n                        vscode.Uri.parse(\n                            'https://github.com/Inferara/inference/releases',\n                        ),\n                    );\n                }\n            });\n        return;\n    }\n    outputChannel.appendLine(`Platform: ${platform.id}`);\n\n    const infsPath = detectInfs();\n    if (!infsPath) {\n        outputChannel.appendLine('infs binary not found.');\n        updateStatusBar(statusBarItem, null);\n        const settings = getSettings();\n        if (settings.autoInstall) {\n            notifyMissing();\n        }\n        return;\n    }\n    outputChannel.appendLine(`infs found: ${infsPath}`);\n\n    const versionOk = await checkInfsVersion(infsPath);\n    if (!versionOk) {\n        updateStatusBar(statusBarItem, null);\n        return;\n    }\n\n    outputChannel.appendLine('Toolchain detection complete.');\n\n    const doctorResult = await runDoctor(infsPath);\n    updateStatusBar(statusBarItem, doctorResult);\n\n    checkForUpdates(infsPath, outputChannel).catch((err) =>\n        outputChannel.appendLine(`Update check failed: ${err}`),\n    );\n}\n\n/**\n * Run `infs version` and check the output against MIN_INFS_VERSION.\n * Returns true if version is acceptable.\n */\nasync function checkInfsVersion(infsPath: string): Promise<boolean> {\n    try {\n        const result = await exec(infsPath, ['version']);\n        if (result.exitCode !== 0) {\n            outputChannel.appendLine(\n                `infs version failed (exit ${result.exitCode}): ${result.stderr}`,\n            );\n            return false;\n        }\n        // Output format: \"infs 0.1.0\"\n        const match = result.stdout.match(/^infs\\s+(\\S+)/);\n        if (!match) {\n            outputChannel.appendLine(\n                `Could not parse infs version from: ${result.stdout.trim()}`,\n            );\n            return false;\n        }\n        const version = match[1];\n        outputChannel.appendLine(`infs version: ${version}`);\n\n        if (compareSemver(version, MIN_INFS_VERSION) < 0) {\n            outputChannel.appendLine(\n                `infs version ${version} is below minimum ${MIN_INFS_VERSION}.`,\n            );\n            vscode.window.showWarningMessage(\n                `Inference: infs version ${version} is outdated (minimum: ${MIN_INFS_VERSION}). Please update.`,\n                'Update',\n            );\n            return false;\n        }\n        return true;\n    } catch (err) {\n        outputChannel.appendLine(`Failed to run infs version: ${err}`);\n        return false;\n    }\n}\n\nfunction notifyMissing(): void {\n    vscode.window\n        .showInformationMessage(\n            'Inference toolchain not found. Would you like to install it?',\n            'Install',\n            'Download Manually',\n            'Configure Path',\n        )\n        .then((action) => {\n            if (action === 'Install') {\n                vscode.commands.executeCommand('inference.installToolchain');\n            } else if (action === 'Download Manually') {\n                vscode.env.openExternal(\n                    vscode.Uri.parse(\n                        'https://github.com/Inferara/inference/releases',\n                    ),\n                );\n            } else if (action === 'Configure Path') {\n                vscode.commands.executeCommand(\n                    'workbench.action.openSettings',\n                    'inference.path',\n                );\n            }\n        });\n}\n", "import * as os from 'os';\n\nexport type PlatformId = 'linux-x64' | 'macos-arm64' | 'windows-x64';\n\nexport interface PlatformInfo {\n    id: PlatformId;\n    archiveExtension: string;\n    binaryName: string;\n}\n\nexport const SUPPORTED_PLATFORMS: Record<string, PlatformId> = {\n    'linux-x64': 'linux-x64',\n    'darwin-arm64': 'macos-arm64',\n    'win32-x64': 'windows-x64',\n};\n\n/**\n * Detect the platform and return its info, or null if unsupported.\n * When osPlatform/osArch are omitted, uses the current runtime values.\n */\nexport function detectPlatform(\n    osPlatform?: string,\n    osArch?: string,\n): PlatformInfo | null {\n    const key = `${osPlatform ?? os.platform()}-${osArch ?? os.arch()}`;\n    const id = SUPPORTED_PLATFORMS[key];\n    if (!id) {\n        return null;\n    }\n    return {\n        id,\n        archiveExtension: id === 'windows-x64' ? '.zip' : '.tar.gz',\n        binaryName: id === 'windows-x64' ? 'infs.exe' : 'infs',\n    };\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { getSettings } from '../config/settings';\nimport { detectPlatform } from './platform';\n\n/** Resolve the INFERENCE_HOME directory (default: ~/.inference). */\nexport function inferenceHome(): string {\n    return process.env['INFERENCE_HOME'] || path.join(os.homedir(), '.inference');\n}\n\n/** Check whether a file exists and is executable (or just exists on Windows). */\nexport function isExecutable(filePath: string): boolean {\n    try {\n        fs.accessSync(filePath, fs.constants.X_OK);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Search PATH for the given binary name.\n * Returns the first match or null.\n */\nexport function findInPath(binaryName: string): string | null {\n    const envPath = process.env['PATH'] || '';\n    const sep = process.platform === 'win32' ? ';' : ':';\n    const dirs = envPath.split(sep).filter(Boolean);\n    for (const dir of dirs) {\n        const candidate = path.join(dir, binaryName);\n        if (isExecutable(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\n\n/**\n * Detect infs binary location.\n *\n * Search order:\n * 1. Custom path from settings (inference.path)\n * 2. System PATH\n * 3. Default managed location (~/.inference/bin/infs)\n *\n * Returns the resolved absolute path or null if not found.\n */\nexport function detectInfs(): string | null {\n    const platform = detectPlatform();\n    const binaryName = platform?.binaryName ?? 'infs';\n\n    const settings = getSettings();\n    if (settings.path) {\n        if (isExecutable(settings.path)) {\n            return settings.path;\n        }\n        return null;\n    }\n\n    const pathResult = findInPath(binaryName);\n    if (pathResult) {\n        return pathResult;\n    }\n\n    const managedPath = path.join(inferenceHome(), 'bin', binaryName);\n    if (isExecutable(managedPath)) {\n        return managedPath;\n    }\n\n    return null;\n}\n", "import * as vscode from 'vscode';\n\nexport type ReleaseChannel = 'stable' | 'latest' | 'none';\n\nexport interface InferenceSettings {\n    /** Custom path to infs binary. Empty string means auto-detect. */\n    path: string;\n    /** Prompt to install toolchain if not found. */\n    autoInstall: boolean;\n    /** Release channel for update checks. */\n    channel: ReleaseChannel;\n    /** Check for toolchain updates on activation. */\n    checkForUpdates: boolean;\n}\n\n/** Read current inference.* configuration values. */\nexport function getSettings(): InferenceSettings {\n    const config = vscode.workspace.getConfiguration('inference');\n    return {\n        path: config.get<string>('path', ''),\n        autoInstall: config.get<boolean>('autoInstall', true),\n        channel: config.get<ReleaseChannel>('channel', 'stable'),\n        checkForUpdates: config.get<boolean>('checkForUpdates', true),\n    };\n}\n", "import * as cp from 'child_process';\n\nexport interface ExecResult {\n    exitCode: number;\n    stdout: string;\n    stderr: string;\n}\n\n/** Default timeout for child processes (30 seconds). */\nconst DEFAULT_TIMEOUT_MS = 30_000;\n\n/**\n * Run a command and capture its output.\n *\n * Resolves with ExecResult on completion (including non-zero exit).\n * Rejects only on spawn failure or timeout.\n */\nexport function exec(\n    command: string,\n    args: string[],\n    options?: { timeoutMs?: number; cwd?: string },\n): Promise<ExecResult> {\n    const timeout = options?.timeoutMs ?? DEFAULT_TIMEOUT_MS;\n    return new Promise((resolve, reject) => {\n        const child = cp.spawn(command, args, {\n            cwd: options?.cwd,\n            stdio: ['ignore', 'pipe', 'pipe'],\n            timeout,\n        });\n\n        const stdoutChunks: Buffer[] = [];\n        const stderrChunks: Buffer[] = [];\n\n        child.stdout.on('data', (chunk: Buffer) => stdoutChunks.push(chunk));\n        child.stderr.on('data', (chunk: Buffer) => stderrChunks.push(chunk));\n\n        child.on('error', (err) => reject(err));\n\n        child.on('close', (code) => {\n            resolve({\n                exitCode: code ?? 1,\n                stdout: Buffer.concat(stdoutChunks).toString('utf-8'),\n                stderr: Buffer.concat(stderrChunks).toString('utf-8'),\n            });\n        });\n    });\n}\n", "/**\n * Compare two semver strings. Returns negative if a < b, 0 if equal, positive if a > b.\n * Only handles numeric major.minor.patch; ignores pre-release tags.\n */\nexport function compareSemver(a: string, b: string): number {\n    const pa = a.split('-')[0].split('.').map(Number);\n    const pb = b.split('-')[0].split('.').map(Number);\n    for (let i = 0; i < 3; i++) {\n        const diff = (pa[i] || 0) - (pb[i] || 0);\n        if (diff !== 0) {\n            return diff;\n        }\n    }\n    return 0;\n}\n", "import * as vscode from 'vscode';\nimport { detectPlatform } from '../toolchain/platform';\nimport {\n    installToolchain,\n    InstallProgress,\n    InstallProgressCallback,\n    InstallResult,\n} from '../toolchain/installation';\n\n/** Guard against concurrent install attempts. */\nlet installing = false;\n\n/**\n * Register the inference.installToolchain command.\n * Returns the Disposable to add to context.subscriptions.\n */\nexport function registerInstallCommand(\n    outputChannel: vscode.OutputChannel,\n): vscode.Disposable {\n    return vscode.commands.registerCommand(\n        'inference.installToolchain',\n        async () => {\n            if (installing) {\n                vscode.window.showInformationMessage(\n                    'Inference toolchain installation is already in progress.',\n                );\n                return;\n            }\n\n            const platform = detectPlatform();\n            if (!platform) {\n                vscode.window.showErrorMessage(\n                    `Inference: unsupported platform (${process.platform}-${process.arch}).`,\n                );\n                return;\n            }\n\n            installing = true;\n            try {\n                const result = await installWithProgress(\n                    platform,\n                    outputChannel,\n                );\n                outputChannel.appendLine(\n                    `Toolchain v${result.version} installed at ${result.infsPath}`,\n                );\n                notifyInstallSuccess(result.version, result.doctorWarnings);\n            } catch (err) {\n                const message =\n                    err instanceof Error ? err.message : String(err);\n                outputChannel.appendLine(`Installation failed: ${message}`);\n                notifyInstallError(message);\n            } finally {\n                installing = false;\n            }\n        },\n    );\n}\n\n/** Run the installation with a VS Code progress notification. */\nfunction installWithProgress(\n    platform: import('../toolchain/platform').PlatformInfo,\n    outputChannel: vscode.OutputChannel,\n): Promise<InstallResult> {\n    return vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Inference Toolchain',\n            cancellable: false,\n        },\n        async (progress) => {\n            const onProgress: InstallProgressCallback = (\n                p: InstallProgress,\n            ) => {\n                outputChannel.appendLine(p.message);\n                if (p.stage === 'downloading' && p.bytesTotal) {\n                    const pct = Math.round(\n                        ((p.bytesReceived ?? 0) / p.bytesTotal) * 100,\n                    );\n                    progress.report({ message: `${p.message} (${pct}%)` });\n                } else {\n                    progress.report({ message: p.message });\n                }\n            };\n            return installToolchain(platform, onProgress);\n        },\n    );\n}\n\n/** Show a notification that the toolchain was installed successfully. */\nfunction notifyInstallSuccess(\n    version: string,\n    doctorWarnings: boolean,\n): void {\n    if (doctorWarnings) {\n        vscode.window\n            .showWarningMessage(\n                `Inference toolchain v${version} installed, but doctor reported issues. See output for details.`,\n                'Show Output',\n            )\n            .then((action) => {\n                if (action === 'Show Output') {\n                    vscode.commands.executeCommand('inference.showOutput');\n                }\n            });\n    } else {\n        vscode.window\n            .showInformationMessage(\n                `Inference toolchain v${version} installed successfully.`,\n                'Show Output',\n            )\n            .then((action) => {\n                if (action === 'Show Output') {\n                    vscode.commands.executeCommand('inference.showOutput');\n                }\n            });\n    }\n}\n\n/** Show an error notification for installation failure. */\nfunction notifyInstallError(errorMessage: string): void {\n    vscode.window\n        .showErrorMessage(\n            `Inference toolchain installation failed: ${errorMessage}`,\n            'Retry',\n            'Download Manually',\n            'Settings',\n        )\n        .then((action) => {\n            if (action === 'Retry') {\n                vscode.commands.executeCommand('inference.installToolchain');\n            } else if (action === 'Download Manually') {\n                vscode.env.openExternal(\n                    vscode.Uri.parse(\n                        'https://github.com/Inferara/inference/releases',\n                    ),\n                );\n            } else if (action === 'Settings') {\n                vscode.commands.executeCommand(\n                    'workbench.action.openSettings',\n                    'inference.path',\n                );\n            }\n        });\n}\n", "import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { PlatformInfo } from './platform';\nimport { inferenceHome } from './detection';\nimport { getSettings } from '../config/settings';\nimport { fetchJson, downloadFile, sha256File } from '../utils/download';\nimport { extractArchive } from '../utils/extract';\nimport { exec } from '../utils/exec';\nimport {\n    ReleaseEntry,\n    findLatestRelease,\n} from './manifest';\n\nexport type { FileEntry, ReleaseEntry } from './manifest';\nexport { findLatestRelease } from './manifest';\n\n/** Progress updates emitted during installation. */\nexport interface InstallProgress {\n    stage:\n        | 'fetching-manifest'\n        | 'downloading'\n        | 'extracting'\n        | 'installing'\n        | 'verifying';\n    message: string;\n    bytesReceived?: number;\n    bytesTotal?: number;\n}\n\nexport type InstallProgressCallback = (progress: InstallProgress) => void;\n\n/** Result of a successful installation. */\nexport interface InstallResult {\n    infsPath: string;\n    version: string;\n    doctorWarnings: boolean;\n}\n\nexport const MANIFEST_URL = 'https://inference-lang.org/releases.json';\n\n/**\n * Run the full installation flow.\n * Fetches manifest, downloads infs, extracts, runs `infs install`, verifies with `infs doctor`.\n * Throws on failure with a descriptive error message.\n */\nexport async function installToolchain(\n    platform: PlatformInfo,\n    onProgress?: InstallProgressCallback,\n): Promise<InstallResult> {\n    const settings = getSettings();\n    const channel =\n        settings.channel === 'stable' || settings.channel === 'latest'\n            ? settings.channel\n            : 'stable';\n\n    onProgress?.({\n        stage: 'fetching-manifest',\n        message: 'Fetching release manifest...',\n    });\n\n    const manifest = await fetchJson<ReleaseEntry[]>(MANIFEST_URL);\n\n    const match = findLatestRelease(manifest, platform, channel);\n    if (!match) {\n        throw new Error(\n            `No compatible infs release found for ${platform.id} in the ${channel} channel.`,\n        );\n    }\n\n    const { release, fileUrl, sha256 } = match;\n    const version = release.version;\n\n    onProgress?.({\n        stage: 'downloading',\n        message: `Downloading infs v${version}...`,\n    });\n\n    const destDir = path.join(inferenceHome(), 'bin');\n    fs.mkdirSync(destDir, { recursive: true });\n\n    const archiveName = `infs-${platform.id}${platform.archiveExtension}`;\n    const archivePath = path.join(os.tmpdir(), archiveName);\n\n    try {\n        await downloadFile(fileUrl, {\n            destPath: archivePath,\n            onProgress: (received, total) => {\n                onProgress?.({\n                    stage: 'downloading',\n                    message: `Downloading infs v${version}...`,\n                    bytesReceived: received,\n                    bytesTotal: total,\n                });\n            },\n        });\n\n        const actualHash = await sha256File(archivePath);\n        if (actualHash !== sha256) {\n            throw new Error(\n                `SHA-256 verification failed for infs v${version}. Expected ${sha256}, got ${actualHash}.`,\n            );\n        }\n\n        onProgress?.({\n            stage: 'extracting',\n            message: 'Extracting archive...',\n        });\n\n        await extractArchive({ archivePath, destDir });\n    } finally {\n        try {\n            fs.unlinkSync(archivePath);\n        } catch {\n            // best-effort cleanup\n        }\n    }\n\n    const infsPath = path.join(destDir, platform.binaryName);\n    if (!fs.existsSync(infsPath)) {\n        throw new Error(\n            `infs binary not found at ${infsPath} after extraction.`,\n        );\n    }\n\n    onProgress?.({\n        stage: 'installing',\n        message: 'Running infs install...',\n    });\n\n    const installResult = await exec(infsPath, ['install'], {\n        timeoutMs: 120_000,\n    });\n    if (installResult.exitCode !== 0) {\n        throw new Error(\n            `infs install failed (exit ${installResult.exitCode}): ${installResult.stderr || installResult.stdout}`,\n        );\n    }\n\n    onProgress?.({\n        stage: 'verifying',\n        message: 'Verifying installation...',\n    });\n\n    let doctorWarnings = false;\n    try {\n        const doctorResult = await exec(infsPath, ['doctor'], {\n            timeoutMs: 30_000,\n        });\n        if (doctorResult.exitCode !== 0) {\n            doctorWarnings = true;\n        }\n    } catch {\n        doctorWarnings = true;\n    }\n\n    return { infsPath, version, doctorWarnings };\n}\n", "import * as https from 'https';\nimport * as http from 'http';\nimport * as fs from 'fs';\nimport * as crypto from 'crypto';\n\n/** Callback invoked during download with bytes received and total (if known). */\nexport type ProgressCallback = (\n    received: number,\n    total: number | undefined,\n) => void;\n\nexport interface DownloadOptions {\n    /** Absolute path where the downloaded file will be saved. */\n    destPath: string;\n    /** Optional progress callback. */\n    onProgress?: ProgressCallback;\n    /** Connection timeout in milliseconds (default: 15000). */\n    timeoutMs?: number;\n}\n\nconst DEFAULT_TIMEOUT_MS = 15_000;\nconst MAX_REDIRECTS = 5;\n\nconst SOCKET_TIMEOUT_MS = 15_000;\n\n/**\n * Perform an HTTPS GET request following redirects.\n * Rejects HTTPS-to-HTTP downgrades.\n */\nfunction followRedirects(\n    url: string,\n    remaining: number,\n): Promise<http.IncomingMessage> {\n    return new Promise((resolve, reject) => {\n        const parsed = new URL(url);\n        const requester = parsed.protocol === 'https:' ? https : http;\n\n        const req = requester.get(url, (res) => {\n            const status = res.statusCode ?? 0;\n\n            if (status >= 300 && status < 400 && res.headers.location) {\n                if (remaining <= 0) {\n                    res.resume();\n                    reject(new Error(`Too many redirects fetching ${url}`));\n                    return;\n                }\n                const target = new URL(res.headers.location, url).href;\n                const targetProtocol = new URL(target).protocol;\n                if (parsed.protocol === 'https:' && targetProtocol === 'http:') {\n                    res.resume();\n                    reject(\n                        new Error(\n                            `Refusing HTTPS-to-HTTP redirect: ${url} -> ${target}`,\n                        ),\n                    );\n                    return;\n                }\n                res.resume();\n                followRedirects(target, remaining - 1).then(resolve, reject);\n                return;\n            }\n\n            if (status < 200 || status >= 300) {\n                res.resume();\n                reject(new Error(`HTTP ${status} fetching ${url}`));\n                return;\n            }\n\n            resolve(res);\n        });\n\n        req.setTimeout(SOCKET_TIMEOUT_MS, () => {\n            req.destroy(new Error(`Connection timed out for ${url}`));\n        });\n\n        req.on('error', (err) =>\n            reject(new Error(`Network error fetching ${url}: ${err.message}`)),\n        );\n    });\n}\n\n/**\n * Fetch a JSON document from a URL via HTTPS GET.\n * Follows up to 5 redirects. Rejects HTTPS-to-HTTP downgrades.\n */\nexport function fetchJson<T>(url: string): Promise<T> {\n    return new Promise((resolve, reject) => {\n        followRedirects(url, MAX_REDIRECTS).then(\n            (res) => {\n                const chunks: Buffer[] = [];\n                res.on('data', (chunk: Buffer) => chunks.push(chunk));\n                res.on('end', () => {\n                    try {\n                        const text = Buffer.concat(chunks).toString('utf-8');\n                        resolve(JSON.parse(text) as T);\n                    } catch (err) {\n                        reject(\n                            new Error(\n                                `Failed to parse JSON from ${url}: ${err instanceof Error ? err.message : err}`,\n                            ),\n                        );\n                    }\n                });\n                res.on('error', (err) =>\n                    reject(\n                        new Error(\n                            `Error reading response from ${url}: ${err.message}`,\n                        ),\n                    ),\n                );\n            },\n            (err) => reject(err),\n        );\n    });\n}\n\n/**\n * Download a file from a URL to destPath using streaming.\n * Uses a temp file (.partial suffix) and renames on completion.\n * Follows redirects (GitHub releases redirect to CDN).\n */\nexport function downloadFile(\n    url: string,\n    options: DownloadOptions,\n): Promise<void> {\n    const timeout = options.timeoutMs ?? DEFAULT_TIMEOUT_MS;\n    const partialPath = options.destPath + '.partial';\n\n    return new Promise((resolve, reject) => {\n        followRedirects(url, MAX_REDIRECTS).then(\n            (res) => {\n                const totalStr = res.headers['content-length'];\n                const total = totalStr ? parseInt(totalStr, 10) : undefined;\n                let received = 0;\n\n                const ws = fs.createWriteStream(partialPath);\n\n                res.on('data', (chunk: Buffer) => {\n                    received += chunk.length;\n                    options.onProgress?.(received, total);\n                });\n\n                res.pipe(ws);\n\n                const cleanup = () => {\n                    try {\n                        fs.unlinkSync(partialPath);\n                    } catch {\n                        // ignore\n                    }\n                };\n\n                ws.on('finish', () => {\n                    try {\n                        fs.renameSync(partialPath, options.destPath);\n                        resolve();\n                    } catch (err) {\n                        cleanup();\n                        reject(\n                            new Error(\n                                `Failed to save download to ${options.destPath}: ${err instanceof Error ? err.message : err}`,\n                            ),\n                        );\n                    }\n                });\n\n                ws.on('error', (err) => {\n                    cleanup();\n                    reject(\n                        new Error(\n                            `Failed to write download: ${err.message}`,\n                        ),\n                    );\n                });\n\n                res.on('error', (err) => {\n                    ws.destroy();\n                    cleanup();\n                    reject(\n                        new Error(\n                            `Download stream error from ${url}: ${err.message}`,\n                        ),\n                    );\n                });\n\n                // No-data timeout: if no bytes arrive for `timeout` ms, abort\n                let dataTimer: ReturnType<typeof setTimeout> | undefined;\n                const resetTimer = () => {\n                    if (dataTimer) {\n                        clearTimeout(dataTimer);\n                    }\n                    dataTimer = setTimeout(() => {\n                        res.destroy();\n                        ws.destroy();\n                        cleanup();\n                        reject(new Error(`Download timed out for ${url}`));\n                    }, timeout);\n                };\n                resetTimer();\n                res.on('data', resetTimer);\n                res.on('end', () => {\n                    if (dataTimer) {\n                        clearTimeout(dataTimer);\n                    }\n                });\n            },\n            (err) => reject(err),\n        );\n    });\n}\n\n/**\n * Compute SHA-256 hash of a file.\n * Returns lowercase hex string.\n */\nexport function sha256File(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const hash = crypto.createHash('sha256');\n        const stream = fs.createReadStream(filePath);\n        stream.on('data', (chunk) => hash.update(chunk));\n        stream.on('end', () => resolve(hash.digest('hex')));\n        stream.on('error', (err) =>\n            reject(\n                new Error(\n                    `Failed to compute SHA-256 for ${filePath}: ${err.message}`,\n                ),\n            ),\n        );\n    });\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\nimport { exec } from './exec';\n\nexport interface ExtractOptions {\n    /** Path to the archive file. */\n    archivePath: string;\n    /** Directory to extract into (created if it doesn't exist). */\n    destDir: string;\n}\n\n/**\n * Extract an archive to the destination directory.\n * Detects format from file extension (.tar.gz or .zip).\n * On Unix, sets executable permission on extracted binaries.\n */\nexport async function extractArchive(options: ExtractOptions): Promise<void> {\n    fs.mkdirSync(options.destDir, { recursive: true });\n\n    if (\n        options.archivePath.endsWith('.tar.gz') ||\n        options.archivePath.endsWith('.tgz')\n    ) {\n        await extractTarGz(options.archivePath, options.destDir);\n    } else if (options.archivePath.endsWith('.zip')) {\n        await extractZip(options.archivePath, options.destDir);\n    } else {\n        throw new Error(\n            `Unsupported archive format: ${path.basename(options.archivePath)}`,\n        );\n    }\n\n    if (process.platform !== 'win32') {\n        setExecutablePermissions(options.destDir);\n    }\n}\n\nasync function extractTarGz(\n    archivePath: string,\n    destDir: string,\n): Promise<void> {\n    const result = await exec('tar', ['-xzf', archivePath, '-C', destDir]);\n    if (result.exitCode !== 0) {\n        throw new Error(\n            `tar extraction failed (exit ${result.exitCode}): ${result.stderr}`,\n        );\n    }\n}\n\nasync function extractZip(\n    archivePath: string,\n    destDir: string,\n): Promise<void> {\n    const result = await exec('powershell', [\n        '-NoProfile',\n        '-Command',\n        `Expand-Archive -Path '${archivePath}' -DestinationPath '${destDir}' -Force`,\n    ]);\n    if (result.exitCode !== 0) {\n        throw new Error(\n            `zip extraction failed (exit ${result.exitCode}): ${result.stderr}`,\n        );\n    }\n}\n\n/** Set executable permissions on files in the directory (non-recursive, top level only). */\nfunction setExecutablePermissions(dir: string): void {\n    try {\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\n        for (const entry of entries) {\n            if (entry.isFile()) {\n                const filePath = path.join(dir, entry.name);\n                fs.chmodSync(filePath, 0o755);\n            }\n        }\n    } catch {\n        // Best-effort: don't fail if chmod fails\n    }\n}\n", "import { compareSemver } from '../utils/semver';\n\n/** A platform-specific file entry from the manifest. */\nexport interface FileEntry {\n    url: string;\n    sha256: string;\n}\n\n/** A single release entry from the manifest. */\nexport interface ReleaseEntry {\n    version: string;\n    stable: boolean;\n    files: FileEntry[];\n}\n\n/** Minimal platform info needed for manifest matching. */\nexport interface ManifestPlatform {\n    id: string;\n}\n\n/**\n * Extract tool name from a manifest file URL.\n * URL format: `https://.../tool-os-arch.ext` (e.g., `infs-linux-x64.tar.gz`).\n */\nexport function toolFromUrl(url: string): string {\n    const filename = url.split('/').pop() ?? '';\n    return filename.split('-')[0] ?? '';\n}\n\n/**\n * Extract OS name from a manifest file URL.\n * URL format: `https://.../tool-os-arch.ext` (e.g., `infs-linux-x64.tar.gz`).\n */\nexport function osFromUrl(url: string): string {\n    const filename = url.split('/').pop() ?? '';\n    const parts = filename.split('-');\n    return parts.length > 1 ? parts[1] : '';\n}\n\n/** Map platform ID to the OS string used in manifest URLs. */\nexport function platformOs(platform: ManifestPlatform): string {\n    if (platform.id === 'linux-x64') {\n        return 'linux';\n    }\n    if (platform.id === 'macos-arm64') {\n        return 'macos';\n    }\n    if (platform.id === 'windows-x64') {\n        return 'windows';\n    }\n    return '';\n}\n\n/**\n * Find the latest release from the manifest for the given platform.\n * Matches the `infs` tool artifact for the platform's OS.\n * Returns the release entry, file URL, and sha256, or null if not found.\n */\nexport function findLatestRelease(\n    manifest: ReleaseEntry[],\n    platform: ManifestPlatform,\n    channel: 'stable' | 'latest',\n): { release: ReleaseEntry; fileUrl: string; sha256: string } | null {\n    const candidates =\n        channel === 'stable' ? manifest.filter((e) => e.stable) : manifest;\n\n    if (candidates.length === 0) {\n        return null;\n    }\n\n    const sorted = [...candidates].sort((a, b) =>\n        compareSemver(b.version, a.version),\n    );\n\n    const os = platformOs(platform);\n\n    for (const release of sorted) {\n        const file = release.files.find(\n            (f) => toolFromUrl(f.url) === 'infs' && osFromUrl(f.url) === os,\n        );\n        if (file) {\n            return { release, fileUrl: file.url, sha256: file.sha256 };\n        }\n    }\n\n    return null;\n}\n", "import * as vscode from 'vscode';\nimport { detectInfs } from '../toolchain/detection';\nimport { runDoctor, DoctorResult } from '../toolchain/doctor';\nimport { updateStatusBar } from '../ui/statusBar';\n\n/** Guard against concurrent doctor runs. */\nlet running = false;\n\n/**\n * Register the inference.runDoctor command.\n *\n * When invoked: detect infs \u2192 run doctor \u2192 display results in output\n * channel \u2192 update status bar \u2192 show notification summary.\n */\nexport function registerDoctorCommand(\n    outputChannel: vscode.OutputChannel,\n    statusBarItem: vscode.StatusBarItem,\n): vscode.Disposable {\n    return vscode.commands.registerCommand(\n        'inference.runDoctor',\n        async () => {\n            if (running) {\n                return;\n            }\n\n            const infsPath = detectInfs();\n            if (!infsPath) {\n                outputChannel.appendLine('Doctor: infs binary not found.');\n                updateStatusBar(statusBarItem, null);\n                vscode.window\n                    .showWarningMessage(\n                        'Inference toolchain not found. Install it first.',\n                        'Install',\n                    )\n                    .then((action) => {\n                        if (action === 'Install') {\n                            vscode.commands.executeCommand(\n                                'inference.installToolchain',\n                            );\n                        }\n                    });\n                return;\n            }\n\n            running = true;\n            try {\n                outputChannel.appendLine(\n                    `Running infs doctor (${infsPath})...`,\n                );\n                const result = await runDoctor(infsPath);\n\n                if (!result) {\n                    outputChannel.appendLine(\n                        'Doctor: failed to execute infs doctor.',\n                    );\n                    updateStatusBar(statusBarItem, null);\n                    vscode.window.showErrorMessage(\n                        'Inference: Failed to run doctor. See output for details.',\n                    );\n                    return;\n                }\n\n                formatDoctorOutput(outputChannel, result);\n                updateStatusBar(statusBarItem, result);\n\n                if (result.hasErrors) {\n                    vscode.window\n                        .showErrorMessage(\n                            `Inference doctor: ${result.summary}`,\n                            'Show Output',\n                        )\n                        .then((action) => {\n                            if (action === 'Show Output') {\n                                outputChannel.show();\n                            }\n                        });\n                } else if (result.hasWarnings) {\n                    vscode.window\n                        .showWarningMessage(\n                            `Inference doctor: ${result.summary}`,\n                            'Show Output',\n                        )\n                        .then((action) => {\n                            if (action === 'Show Output') {\n                                outputChannel.show();\n                            }\n                        });\n                } else {\n                    vscode.window.showInformationMessage(\n                        'Inference: Toolchain is healthy.',\n                    );\n                }\n            } finally {\n                running = false;\n            }\n        },\n    );\n}\n\nconst STATUS_TAGS: Record<string, string> = {\n    ok: '[OK]  ',\n    warn: '[WARN]',\n    fail: '[FAIL]',\n};\n\nfunction formatDoctorOutput(\n    outputChannel: vscode.OutputChannel,\n    result: DoctorResult,\n): void {\n    outputChannel.appendLine('--- Doctor Report ---');\n    for (const check of result.checks) {\n        const tag = STATUS_TAGS[check.status] ?? `[${check.status.toUpperCase()}]`;\n        outputChannel.appendLine(`  ${tag} ${check.name}: ${check.message}`);\n    }\n    if (result.summary) {\n        outputChannel.appendLine('');\n        outputChannel.appendLine(result.summary);\n    }\n    outputChannel.appendLine('---------------------');\n}\n", "import { exec } from '../utils/exec';\n\nexport type DoctorCheckStatus = 'ok' | 'warn' | 'fail';\n\nexport interface DoctorCheck {\n    name: string;\n    status: DoctorCheckStatus;\n    message: string;\n}\n\nexport interface DoctorResult {\n    checks: DoctorCheck[];\n    hasErrors: boolean;\n    hasWarnings: boolean;\n    summary: string;\n}\n\nconst STATUS_MAP: Record<string, DoctorCheckStatus> = {\n    OK: 'ok',\n    WARN: 'warn',\n    FAIL: 'fail',\n};\n\n/**\n * Check line format: `  [OK|WARN|FAIL] <name>: <message>`\n *\n * PATH conflict continuation lines (indented without a status prefix)\n * are intentionally not captured as individual checks.\n */\nconst CHECK_PATTERN = /^\\s+\\[(OK|WARN|FAIL)]\\s+(.+?):\\s+(.*)/;\n\n/**\n * Parse the stdout of `infs doctor` into a structured result.\n *\n * The output format is a public contract defined in\n * `apps/infs/src/commands/doctor.rs`.\n */\nexport function parseDoctorOutput(stdout: string): DoctorResult {\n    const checks: DoctorCheck[] = [];\n    const lines = stdout.split('\\n');\n\n    for (const line of lines) {\n        const match = line.match(CHECK_PATTERN);\n        if (match) {\n            checks.push({\n                status: STATUS_MAP[match[1]],\n                name: match[2].trim(),\n                message: match[3].trim(),\n            });\n        }\n    }\n\n    let summary = '';\n    for (let i = lines.length - 1; i >= 0; i--) {\n        const trimmed = lines[i].trim();\n        if (trimmed.length > 0 && !CHECK_PATTERN.test(lines[i])) {\n            summary = trimmed;\n            break;\n        }\n    }\n\n    return {\n        checks,\n        hasErrors: checks.some((c) => c.status === 'fail'),\n        hasWarnings: checks.some((c) => c.status === 'warn'),\n        summary,\n    };\n}\n\n/**\n * Execute `infs doctor` and return the parsed result.\n * Returns null if execution fails (e.g., binary not found or crash).\n */\nexport async function runDoctor(\n    infsPath: string,\n): Promise<DoctorResult | null> {\n    try {\n        const result = await exec(infsPath, ['doctor']);\n        return parseDoctorOutput(result.stdout);\n    } catch {\n        return null;\n    }\n}\n", "import * as vscode from 'vscode';\nimport { DoctorResult } from '../toolchain/doctor';\n\n/**\n * Create the Inference status bar item.\n * Positioned on the left side with low priority.\n * Clicking triggers the inference.runDoctor command.\n */\nexport function createStatusBar(): vscode.StatusBarItem {\n    const item = vscode.window.createStatusBarItem(\n        vscode.StatusBarAlignment.Left,\n        0,\n    );\n    item.command = 'inference.runDoctor';\n    item.text = '$(loading~spin) Inference';\n    item.tooltip = 'Inference: Checking toolchain...';\n    item.show();\n    return item;\n}\n\n/**\n * Update the status bar to reflect doctor results.\n *\n * - null: toolchain not found (grey dash icon)\n * - hasErrors: red error icon\n * - hasWarnings: yellow warning icon\n * - all OK: green check icon\n */\nexport function updateStatusBar(\n    item: vscode.StatusBarItem,\n    result: DoctorResult | null,\n): void {\n    if (result === null) {\n        item.text = '$(dash) Inference';\n        item.tooltip = 'Inference: Toolchain not found. Click to run doctor.';\n        item.backgroundColor = undefined;\n        return;\n    }\n\n    if (result.hasErrors) {\n        item.text = '$(error) Inference';\n        item.tooltip = `Inference: ${result.summary || 'Toolchain errors detected'}`;\n        item.backgroundColor = new vscode.ThemeColor(\n            'statusBarItem.errorBackground',\n        );\n        return;\n    }\n\n    if (result.hasWarnings) {\n        item.text = '$(warning) Inference';\n        item.tooltip = `Inference: ${result.summary || 'Toolchain warnings detected'}`;\n        item.backgroundColor = new vscode.ThemeColor(\n            'statusBarItem.warningBackground',\n        );\n        return;\n    }\n\n    item.text = '$(check) Inference';\n    item.tooltip = 'Inference: Toolchain healthy';\n    item.backgroundColor = undefined;\n}\n", "import * as vscode from 'vscode';\nimport { detectInfs } from '../toolchain/detection';\nimport { fetchVersions, getCurrentVersion, installAndSetDefault } from '../toolchain/versions';\nimport { compareSemver } from '../utils/semver';\n\n/** Guard against concurrent select operations. */\nlet selecting = false;\n\n/**\n * Register the inference.selectVersion command.\n * Shows a QuickPick with available toolchain versions and switches to the selected one.\n */\nexport function registerSelectVersionCommand(\n    outputChannel: vscode.OutputChannel,\n): vscode.Disposable {\n    return vscode.commands.registerCommand(\n        'inference.selectVersion',\n        async () => {\n            if (selecting) {\n                vscode.window.showInformationMessage(\n                    'Version selection is already in progress.',\n                );\n                return;\n            }\n\n            const infsPath = detectInfs();\n            if (!infsPath) {\n                vscode.window\n                    .showWarningMessage(\n                        'Inference toolchain not found. Install it first.',\n                        'Install',\n                    )\n                    .then((action) => {\n                        if (action === 'Install') {\n                            vscode.commands.executeCommand(\n                                'inference.installToolchain',\n                            );\n                        }\n                    });\n                return;\n            }\n\n            selecting = true;\n            try {\n                const versions = await fetchVersions(infsPath);\n                if (!versions) {\n                    vscode.window.showErrorMessage(\n                        'Inference: Failed to fetch available versions.',\n                    );\n                    return;\n                }\n\n                const currentVersion = await getCurrentVersion(infsPath);\n\n                // Filter to versions available for current platform and sort by semver descending\n                const available = versions\n                    .filter((v) => v.available_for_current)\n                    .sort((a, b) => compareSemver(b.version, a.version));\n\n                if (available.length === 0) {\n                    vscode.window.showInformationMessage(\n                        'No toolchain versions available for this platform.',\n                    );\n                    return;\n                }\n\n                const items: vscode.QuickPickItem[] = available.map((v) => {\n                    const tags: string[] = [];\n                    if (v.version === currentVersion) {\n                        tags.push('current');\n                    }\n                    if (v.stable) {\n                        tags.push('stable');\n                    }\n                    return {\n                        label: v.version,\n                        description: tags.length > 0 ? `(${tags.join(', ')})` : undefined,\n                    };\n                });\n\n                if (currentVersion) {\n                    const idx = items.findIndex((i) => i.label === currentVersion);\n                    if (idx > 0) {\n                        const [item] = items.splice(idx, 1);\n                        items.unshift(item);\n                    }\n                }\n\n                const picked = await vscode.window.showQuickPick(items, {\n                    placeHolder: 'Select toolchain version',\n                    matchOnDescription: true,\n                });\n\n                if (!picked) {\n                    return;\n                }\n\n                const selectedVersion = picked.label;\n                if (selectedVersion === currentVersion) {\n                    vscode.window.showInformationMessage(\n                        `Already using toolchain v${selectedVersion}.`,\n                    );\n                    return;\n                }\n\n                await switchVersion(infsPath, selectedVersion, outputChannel);\n            } finally {\n                selecting = false;\n            }\n        },\n    );\n}\n\nasync function switchVersion(\n    infsPath: string,\n    version: string,\n    outputChannel: vscode.OutputChannel,\n): Promise<void> {\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Inference Toolchain',\n            cancellable: false,\n        },\n        async (progress) => {\n            progress.report({ message: `Switching to v${version}...` });\n            outputChannel.appendLine(`Switching to toolchain v${version}...`);\n\n            const result = await installAndSetDefault(infsPath, version);\n\n            if (result.success) {\n                outputChannel.appendLine(`Switched to toolchain v${version}.`);\n                vscode.window\n                    .showInformationMessage(\n                        `Switched to Inference toolchain v${version}.`,\n                        'Show Output',\n                    )\n                    .then((action) => {\n                        if (action === 'Show Output') {\n                            outputChannel.show();\n                        }\n                    });\n                return;\n            }\n\n            outputChannel.appendLine(`Version switch failed: ${result.error}`);\n\n            if (result.installedButNotDefault) {\n                vscode.window\n                    .showWarningMessage(\n                        `Inference: v${version} was installed but could not be set as default. Run \\`infs default ${version}\\` manually.`,\n                        'Show Output',\n                    )\n                    .then((action) => {\n                        if (action === 'Show Output') {\n                            outputChannel.show();\n                        }\n                    });\n            } else {\n                vscode.window.showErrorMessage(\n                    `Inference: Failed to install v${version}: ${result.error}`,\n                );\n            }\n        },\n    );\n}\n", "import { exec } from '../utils/exec';\n\n/** Version info returned by `infs versions --json`. */\nexport interface VersionInfo {\n    version: string;\n    stable: boolean;\n    platforms: string[];\n    available_for_current: boolean;\n}\n\n/**\n * Parse the JSON output of `infs versions --json`.\n * Returns an empty array if the output is invalid.\n */\nexport function parseVersionsOutput(stdout: string): VersionInfo[] {\n    try {\n        const parsed = JSON.parse(stdout);\n        if (!Array.isArray(parsed)) {\n            return [];\n        }\n        return parsed;\n    } catch {\n        return [];\n    }\n}\n\n/**\n * Parse the version string from `infs version` output.\n * Expected format: \"infs X.Y.Z\"\n * Returns the version string or null on parse failure.\n */\nexport function parseCurrentVersion(stdout: string): string | null {\n    const match = stdout.match(/^infs\\s+(\\S+)/);\n    return match ? match[1] : null;\n}\n\n/**\n * Run `infs versions --json` and parse the output.\n * Returns null if the command fails.\n */\nexport async function fetchVersions(\n    infsPath: string,\n): Promise<VersionInfo[] | null> {\n    try {\n        const result = await exec(infsPath, ['versions', '--json']);\n        if (result.exitCode !== 0) {\n            return null;\n        }\n        return parseVersionsOutput(result.stdout);\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Run `infs version` and parse the current version.\n * Returns null if the command fails or the output is unexpected.\n */\nexport async function getCurrentVersion(\n    infsPath: string,\n): Promise<string | null> {\n    try {\n        const result = await exec(infsPath, ['version']);\n        if (result.exitCode !== 0) {\n            return null;\n        }\n        return parseCurrentVersion(result.stdout);\n    } catch {\n        return null;\n    }\n}\n\n/** Result of an install-and-set-default operation. */\nexport interface SwitchResult {\n    success: boolean;\n    installedButNotDefault: boolean;\n    error?: string;\n}\n\n/**\n * Install a toolchain version and set it as default.\n *\n * Runs `infs install VERSION` followed by `infs default VERSION`.\n * Handles the partial-success case where install succeeds but setting default fails.\n */\nexport async function installAndSetDefault(\n    infsPath: string,\n    version: string,\n): Promise<SwitchResult> {\n    const installResult = await exec(infsPath, ['install', version], {\n        timeoutMs: 120_000,\n    });\n    if (installResult.exitCode !== 0) {\n        const detail = installResult.stderr || installResult.stdout;\n        return { success: false, installedButNotDefault: false, error: detail };\n    }\n\n    const defaultResult = await exec(infsPath, ['default', version]);\n    if (defaultResult.exitCode !== 0) {\n        const detail = defaultResult.stderr || defaultResult.stdout;\n        return { success: false, installedButNotDefault: true, error: detail };\n    }\n\n    return { success: true, installedButNotDefault: false };\n}\n", "import * as vscode from 'vscode';\nimport { detectInfs } from '../toolchain/detection';\nimport { fetchVersions, getCurrentVersion, installAndSetDefault } from '../toolchain/versions';\nimport { compareSemver } from '../utils/semver';\nimport { getSettings } from '../config/settings';\n\n/** Guard against concurrent update operations. */\nlet updating = false;\n\n/**\n * Register the inference.updateToolchain command.\n * Checks for updates and prompts the user to install if available.\n */\nexport function registerUpdateCommand(\n    outputChannel: vscode.OutputChannel,\n): vscode.Disposable {\n    return vscode.commands.registerCommand(\n        'inference.updateToolchain',\n        async () => {\n            if (updating) {\n                vscode.window.showInformationMessage(\n                    'Update check is already in progress.',\n                );\n                return;\n            }\n\n            const infsPath = detectInfs();\n            if (!infsPath) {\n                vscode.window\n                    .showWarningMessage(\n                        'Inference toolchain not found. Install it first.',\n                        'Install',\n                    )\n                    .then((action) => {\n                        if (action === 'Install') {\n                            vscode.commands.executeCommand(\n                                'inference.installToolchain',\n                            );\n                        }\n                    });\n                return;\n            }\n\n            updating = true;\n            try {\n                await checkForUpdatesImpl(infsPath, outputChannel, true);\n            } finally {\n                updating = false;\n            }\n        },\n    );\n}\n\n/**\n * Check for toolchain updates on activation.\n * Respects the `inference.checkForUpdates` and `inference.channel` settings.\n * This is a no-op if checks are disabled.\n */\nexport async function checkForUpdates(\n    infsPath: string,\n    outputChannel: vscode.OutputChannel,\n): Promise<void> {\n    const settings = getSettings();\n    if (!settings.checkForUpdates) {\n        return;\n    }\n    if (settings.channel === 'none') {\n        return;\n    }\n    await checkForUpdatesImpl(infsPath, outputChannel, false);\n}\n\nasync function checkForUpdatesImpl(\n    infsPath: string,\n    outputChannel: vscode.OutputChannel,\n    userInitiated: boolean,\n): Promise<void> {\n    const currentVersion = await getCurrentVersion(infsPath);\n    if (!currentVersion) {\n        outputChannel.appendLine('Update check: could not determine current version.');\n        if (userInitiated) {\n            vscode.window.showErrorMessage(\n                'Inference: Could not determine the current toolchain version.',\n            );\n        }\n        return;\n    }\n\n    outputChannel.appendLine(`Update check: current version is ${currentVersion}.`);\n\n    const versions = await fetchVersions(infsPath);\n    if (!versions) {\n        outputChannel.appendLine('Update check: failed to fetch available versions.');\n        if (userInitiated) {\n            vscode.window.showErrorMessage(\n                'Inference: Failed to check for updates.',\n            );\n        }\n        return;\n    }\n\n    const settings = getSettings();\n    const channel =\n        settings.channel === 'stable' || settings.channel === 'latest'\n            ? settings.channel\n            : 'stable';\n\n    const candidates = versions\n        .filter((v) => v.available_for_current)\n        .filter((v) => (channel === 'stable' ? v.stable : true));\n\n    if (candidates.length === 0) {\n        outputChannel.appendLine('Update check: no versions available for this platform.');\n        if (userInitiated) {\n            vscode.window.showInformationMessage(\n                'Inference: No toolchain versions available for this platform.',\n            );\n        }\n        return;\n    }\n\n    const sorted = [...candidates].sort((a, b) =>\n        compareSemver(b.version, a.version),\n    );\n    const latest = sorted[0];\n\n    if (compareSemver(currentVersion, latest.version) >= 0) {\n        outputChannel.appendLine(\n            `Update check: toolchain is up to date (v${currentVersion}).`,\n        );\n        if (userInitiated) {\n            vscode.window.showInformationMessage(\n                `Inference toolchain is up to date (v${currentVersion}).`,\n            );\n        }\n        return;\n    }\n\n    outputChannel.appendLine(\n        `Update check: v${latest.version} available (current: v${currentVersion}).`,\n    );\n\n    const action = await vscode.window.showInformationMessage(\n        `Inference toolchain update available: v${latest.version} (current: v${currentVersion})`,\n        'Update',\n        'Release Notes',\n    );\n\n    if (action === 'Update') {\n        await performUpdate(infsPath, latest.version, outputChannel);\n    } else if (action === 'Release Notes') {\n        vscode.env.openExternal(\n            vscode.Uri.parse(\n                `https://github.com/Inferara/inference/releases/tag/v${latest.version}`,\n            ),\n        );\n    }\n}\n\nasync function performUpdate(\n    infsPath: string,\n    version: string,\n    outputChannel: vscode.OutputChannel,\n): Promise<void> {\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Inference Toolchain',\n            cancellable: false,\n        },\n        async (progress) => {\n            progress.report({ message: `Updating to v${version}...` });\n            outputChannel.appendLine(`Updating to toolchain v${version}...`);\n\n            const result = await installAndSetDefault(infsPath, version);\n\n            if (result.success) {\n                outputChannel.appendLine(`Updated to toolchain v${version}.`);\n                vscode.window\n                    .showInformationMessage(\n                        `Inference toolchain updated to v${version}.`,\n                        'Show Output',\n                    )\n                    .then((action) => {\n                        if (action === 'Show Output') {\n                            outputChannel.show();\n                        }\n                    });\n                return;\n            }\n\n            outputChannel.appendLine(`Update failed: ${result.error}`);\n\n            if (result.installedButNotDefault) {\n                vscode.window\n                    .showWarningMessage(\n                        `Inference: v${version} was installed but could not be set as default. Run \\`infs default ${version}\\` manually.`,\n                        'Show Output',\n                    )\n                    .then((action) => {\n                        if (action === 'Show Output') {\n                            outputChannel.show();\n                        }\n                    });\n            } else {\n                vscode.window.showErrorMessage(\n                    `Inference: Failed to install v${version}: ${result.error}`,\n                );\n            }\n        },\n    );\n}\n"],
  "mappings": "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",
  "names": ["vscode", "os", "platform", "vscode", "fs", "os", "path", "fs", "DEFAULT_TIMEOUT_MS", "fs", "path", "platform", "os", "platform", "outputChannel", "platform", "vscode", "vscode", "outputChannel", "vscode", "outputChannel", "vscode", "outputChannel", "platform"]
}
