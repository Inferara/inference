{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/toolchain/platform.ts", "../src/toolchain/detection.ts", "../src/config/settings.ts", "../src/utils/exec.ts", "../src/utils/semver.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './toolchain/platform';\nimport { detectInfs } from './toolchain/detection';\nimport { getSettings } from './config/settings';\nimport { exec } from './utils/exec';\nimport { compareSemver } from './utils/semver';\n\n/** Minimum infs CLI version the extension can work with. */\nconst MIN_INFS_VERSION = '0.1.0';\n\nconst outputChannel = vscode.window.createOutputChannel('Inference');\n\nexport function activate(context: vscode.ExtensionContext) {\n    context.subscriptions.push(outputChannel);\n\n    context.subscriptions.push(\n        vscode.commands.registerCommand('inference.showOutput', () => {\n            outputChannel.show();\n        }),\n    );\n\n    // Stub commands for phases 2-4 (registered so VS Code doesn't warn about missing handlers)\n    for (const cmd of [\n        'inference.installToolchain',\n        'inference.updateToolchain',\n        'inference.selectVersion',\n        'inference.runDoctor',\n    ]) {\n        context.subscriptions.push(\n            vscode.commands.registerCommand(cmd, () => {\n                vscode.window.showInformationMessage(\n                    'This command will be available in a future update.',\n                );\n            }),\n        );\n    }\n\n    checkToolchain().catch((err) =>\n        outputChannel.appendLine(`Toolchain check failed: ${err}`),\n    );\n}\n\nexport function deactivate() {\n    // Nothing to clean up\n}\n\nasync function checkToolchain(): Promise<void> {\n    const platform = detectPlatform();\n    if (!platform) {\n        outputChannel.appendLine(\n            `Unsupported platform: ${process.platform}-${process.arch}`,\n        );\n        vscode.window\n            .showWarningMessage(\n                `Inference: unsupported platform (${process.platform}-${process.arch}).`,\n                'Download Page',\n            )\n            .then((action) => {\n                if (action === 'Download Page') {\n                    vscode.env.openExternal(\n                        vscode.Uri.parse(\n                            'https://github.com/Inferara/inference/releases',\n                        ),\n                    );\n                }\n            });\n        return;\n    }\n    outputChannel.appendLine(`Platform: ${platform.id}`);\n\n    const infsPath = detectInfs();\n    if (!infsPath) {\n        outputChannel.appendLine('infs binary not found.');\n        const settings = getSettings();\n        if (settings.autoInstall) {\n            notifyMissing();\n        }\n        return;\n    }\n    outputChannel.appendLine(`infs found: ${infsPath}`);\n\n    const versionOk = await checkInfsVersion(infsPath);\n    if (!versionOk) {\n        return;\n    }\n\n    outputChannel.appendLine('Toolchain detection complete.');\n}\n\n/**\n * Run `infs version` and check the output against MIN_INFS_VERSION.\n * Returns true if version is acceptable.\n */\nasync function checkInfsVersion(infsPath: string): Promise<boolean> {\n    try {\n        const result = await exec(infsPath, ['version']);\n        if (result.exitCode !== 0) {\n            outputChannel.appendLine(\n                `infs version failed (exit ${result.exitCode}): ${result.stderr}`,\n            );\n            return false;\n        }\n        // Output format: \"infs 0.1.0\"\n        const match = result.stdout.match(/^infs\\s+(\\S+)/);\n        if (!match) {\n            outputChannel.appendLine(\n                `Could not parse infs version from: ${result.stdout.trim()}`,\n            );\n            return false;\n        }\n        const version = match[1];\n        outputChannel.appendLine(`infs version: ${version}`);\n\n        if (compareSemver(version, MIN_INFS_VERSION) < 0) {\n            outputChannel.appendLine(\n                `infs version ${version} is below minimum ${MIN_INFS_VERSION}.`,\n            );\n            vscode.window.showWarningMessage(\n                `Inference: infs version ${version} is outdated (minimum: ${MIN_INFS_VERSION}). Please update.`,\n                'Update',\n            );\n            return false;\n        }\n        return true;\n    } catch (err) {\n        outputChannel.appendLine(`Failed to run infs version: ${err}`);\n        return false;\n    }\n}\n\nfunction notifyMissing(): void {\n    vscode.window\n        .showInformationMessage(\n            'Inference toolchain not found. Would you like to install it?',\n            'Install',\n            'Download Manually',\n            'Configure Path',\n        )\n        .then((action) => {\n            if (action === 'Install') {\n                vscode.commands.executeCommand('inference.installToolchain');\n            } else if (action === 'Download Manually') {\n                vscode.env.openExternal(\n                    vscode.Uri.parse(\n                        'https://github.com/Inferara/inference/releases',\n                    ),\n                );\n            } else if (action === 'Configure Path') {\n                vscode.commands.executeCommand(\n                    'workbench.action.openSettings',\n                    'inference.path',\n                );\n            }\n        });\n}\n", "import * as os from 'os';\n\nexport type PlatformId = 'linux-x64' | 'macos-arm64' | 'windows-x64';\n\nexport interface PlatformInfo {\n    id: PlatformId;\n    archiveExtension: string;\n    binaryName: string;\n}\n\nexport const SUPPORTED_PLATFORMS: Record<string, PlatformId> = {\n    'linux-x64': 'linux-x64',\n    'darwin-arm64': 'macos-arm64',\n    'win32-x64': 'windows-x64',\n};\n\n/**\n * Detect the platform and return its info, or null if unsupported.\n * When osPlatform/osArch are omitted, uses the current runtime values.\n */\nexport function detectPlatform(\n    osPlatform?: string,\n    osArch?: string,\n): PlatformInfo | null {\n    const key = `${osPlatform ?? os.platform()}-${osArch ?? os.arch()}`;\n    const id = SUPPORTED_PLATFORMS[key];\n    if (!id) {\n        return null;\n    }\n    return {\n        id,\n        archiveExtension: id === 'windows-x64' ? '.zip' : '.tar.gz',\n        binaryName: id === 'windows-x64' ? 'infs.exe' : 'infs',\n    };\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { getSettings } from '../config/settings';\nimport { detectPlatform } from './platform';\n\n/** Resolve the INFERENCE_HOME directory (default: ~/.inference). */\nexport function inferenceHome(): string {\n    return process.env['INFERENCE_HOME'] || path.join(os.homedir(), '.inference');\n}\n\n/** Check whether a file exists and is executable (or just exists on Windows). */\nexport function isExecutable(filePath: string): boolean {\n    try {\n        fs.accessSync(filePath, fs.constants.X_OK);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Search PATH for the given binary name.\n * Returns the first match or null.\n */\nexport function findInPath(binaryName: string): string | null {\n    const envPath = process.env['PATH'] || '';\n    const sep = process.platform === 'win32' ? ';' : ':';\n    const dirs = envPath.split(sep).filter(Boolean);\n    for (const dir of dirs) {\n        const candidate = path.join(dir, binaryName);\n        if (isExecutable(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\n\n/**\n * Detect infs binary location.\n *\n * Search order:\n * 1. Custom path from settings (inference.path)\n * 2. System PATH\n * 3. Default managed location (~/.inference/bin/infs)\n *\n * Returns the resolved absolute path or null if not found.\n */\nexport function detectInfs(): string | null {\n    const platform = detectPlatform();\n    const binaryName = platform?.binaryName ?? 'infs';\n\n    const settings = getSettings();\n    if (settings.path) {\n        if (isExecutable(settings.path)) {\n            return settings.path;\n        }\n        return null;\n    }\n\n    const pathResult = findInPath(binaryName);\n    if (pathResult) {\n        return pathResult;\n    }\n\n    const managedPath = path.join(inferenceHome(), 'bin', binaryName);\n    if (isExecutable(managedPath)) {\n        return managedPath;\n    }\n\n    return null;\n}\n", "import * as vscode from 'vscode';\n\nexport type ReleaseChannel = 'stable' | 'latest' | 'none';\n\nexport interface InferenceSettings {\n    /** Custom path to infs binary. Empty string means auto-detect. */\n    path: string;\n    /** Prompt to install toolchain if not found. */\n    autoInstall: boolean;\n    /** Release channel for update checks. */\n    channel: ReleaseChannel;\n    /** Check for toolchain updates on activation. */\n    checkForUpdates: boolean;\n}\n\n/** Read current inference.* configuration values. */\nexport function getSettings(): InferenceSettings {\n    const config = vscode.workspace.getConfiguration('inference');\n    return {\n        path: config.get<string>('path', ''),\n        autoInstall: config.get<boolean>('autoInstall', true),\n        channel: config.get<ReleaseChannel>('channel', 'stable'),\n        checkForUpdates: config.get<boolean>('checkForUpdates', true),\n    };\n}\n", "import * as cp from 'child_process';\n\nexport interface ExecResult {\n    exitCode: number;\n    stdout: string;\n    stderr: string;\n}\n\n/** Default timeout for child processes (30 seconds). */\nconst DEFAULT_TIMEOUT_MS = 30_000;\n\n/**\n * Run a command and capture its output.\n *\n * Resolves with ExecResult on completion (including non-zero exit).\n * Rejects only on spawn failure or timeout.\n */\nexport function exec(\n    command: string,\n    args: string[],\n    options?: { timeoutMs?: number; cwd?: string },\n): Promise<ExecResult> {\n    const timeout = options?.timeoutMs ?? DEFAULT_TIMEOUT_MS;\n    return new Promise((resolve, reject) => {\n        const child = cp.spawn(command, args, {\n            cwd: options?.cwd,\n            stdio: ['ignore', 'pipe', 'pipe'],\n            timeout,\n        });\n\n        const stdoutChunks: Buffer[] = [];\n        const stderrChunks: Buffer[] = [];\n\n        child.stdout.on('data', (chunk: Buffer) => stdoutChunks.push(chunk));\n        child.stderr.on('data', (chunk: Buffer) => stderrChunks.push(chunk));\n\n        child.on('error', (err) => reject(err));\n\n        child.on('close', (code) => {\n            resolve({\n                exitCode: code ?? 1,\n                stdout: Buffer.concat(stdoutChunks).toString('utf-8'),\n                stderr: Buffer.concat(stderrChunks).toString('utf-8'),\n            });\n        });\n    });\n}\n", "/**\n * Compare two semver strings. Returns negative if a < b, 0 if equal, positive if a > b.\n * Only handles numeric major.minor.patch; ignores pre-release tags.\n */\nexport function compareSemver(a: string, b: string): number {\n    const pa = a.split('.').map(Number);\n    const pb = b.split('.').map(Number);\n    for (let i = 0; i < 3; i++) {\n        const diff = (pa[i] || 0) - (pb[i] || 0);\n        if (diff !== 0) {\n            return diff;\n        }\n    }\n    return 0;\n}\n"],
  "mappings": "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",
  "names": ["vscode", "os", "platform", "platform"]
}
